SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/ftplugin.vim
Sourced 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    2              0.000013 if exists("did_load_ftplugin")
    1              0.000001   finish
    1              0.000001 endif
    1              0.000004 let did_load_ftplugin = 1
                            
    1              0.000002 augroup filetypeplugin
    1              0.000006   au FileType * call s:LoadFTPlugin()
                            
    1              0.000003   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
                                  endfor
                                endif
                              endfunc
    1              0.000001 augroup END

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/indent.vim
Sourced 2 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    2              0.000014 if exists("did_indent_on")
    1              0.000001   finish
    1              0.000001 endif
    1              0.000004 let did_indent_on = 1
                            
    1              0.000003 augroup filetypeindent
    1              0.000008   au FileType * call s:LoadIndent()
    1              0.000004   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
                                    exe $'runtime! indent/{name}[.]{{vim,lua}}'
                                  endfor
                                endif
                              endfunc
    1              0.000006 augroup END

SCRIPT  /home/nagashima/.config/nvim/init.lua
Sourced 1 time
Total time:   0.050409
 Self time:   0.050409

count  total (s)   self (s)
                            UsingHomePC = os.getenv("HOME_PC")
                            
                            require("plugin")
                            
                            require("other")
                            require("keymap")
                            
                            require("ui")
                            if UsingHomePC then
                              require("home_colorscheme")
                            else
                              require("colorscheme")
                            end
                            
                            require("lsp")

SCRIPT  /home/nagashima/.local/share/nvim/site/autoload/plug.vim
Sourced 1 time
Total time:   0.001152
 Self time:   0.001086

count  total (s)   self (s)
                            " vim-plug: Vim plugin manager
                            " ============================
                            "
                            " 1. Download plug.vim and put it in 'autoload' directory
                            "
                            "   # Vim
                            "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
                            "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                            "
                            "   # Neovim
                            "   sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
                            "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
                            "
                            " 2. Add a vim-plug section to your ~/.vimrc (or ~/.config/nvim/init.vim for Neovim)
                            "
                            "   call plug#begin()
                            "
                            "   " List your plugins here
                            "   Plug 'tpope/vim-sensible'
                            "
                            "   call plug#end()
                            "
                            " 3. Reload the file or restart Vim, then you can,
                            "
                            "     :PlugInstall to install plugins
                            "     :PlugUpdate  to update plugins
                            "     :PlugDiff    to review the changes from the last update
                            "     :PlugClean   to remove plugins no longer in the list
                            "
                            " For more information, see https://github.com/junegunn/vim-plug
                            "
                            "
                            " Copyright (c) 2024 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000009 if exists('g:loaded_plug')
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_plug = 1
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000003 let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
    1              0.000005 let s:plug_tab = get(s:, 'plug_tab', -1)
    1              0.000003 let s:plug_buf = get(s:, 'plug_buf', -1)
    1              0.000008 let s:mac_gui = has('gui_macvim') && has('gui_running')
    1              0.000005 let s:is_win = has('win32')
    1              0.000007 let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
    1              0.000007 let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
    1              0.000003 if s:is_win && &shellslash
                              set noshellslash
                              let s:me = resolve(expand('<sfile>:p'))
                              set shellslash
    1              0.000001 else
    1              0.000022   let s:me = resolve(expand('<sfile>:p'))
    1              0.000001 endif
    1              0.000006 let s:base_spec = { 'branch': '', 'frozen': 0 }
    1              0.000014 let s:TYPE = {
                            \   'string':  type(''),
                            \   'list':    type([]),
                            \   'dict':    type({}),
                            \   'funcref': type(function('call'))
                            \ }
    1              0.000004 let s:loaded = get(s:, 'loaded', {})
    1              0.000003 let s:triggers = get(s:, 'triggers', {})
                            
    1              0.000004 function! s:is_powershell(shell)
                              return a:shell =~# 'powershell\(\.exe\)\?$' || a:shell =~# 'pwsh\(\.exe\)\?$'
                            endfunction
                            
    1              0.000002 function! s:isabsolute(dir) abort
                              return a:dir =~# '^/' || (has('win32') && a:dir =~? '^\%(\\\|[A-Z]:\)')
                            endfunction
                            
    1              0.000002 function! s:git_dir(dir) abort
                              let gitdir = s:trim(a:dir) . '/.git'
                              if isdirectory(gitdir)
                                return gitdir
                              endif
                              if !filereadable(gitdir)
                                return ''
                              endif
                              let gitdir = matchstr(get(readfile(gitdir), 0, ''), '^gitdir: \zs.*')
                              if len(gitdir) && !s:isabsolute(gitdir)
                                let gitdir = a:dir . '/' . gitdir
                              endif
                              return isdirectory(gitdir) ? gitdir : ''
                            endfunction
                            
    1              0.000002 function! s:git_origin_url(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let config = gitdir . '/config'
                              if empty(gitdir) || !filereadable(config)
                                return ''
                              endif
                              return matchstr(join(readfile(config)), '\[remote "origin"\].\{-}url\s*=\s*\zs\S*\ze')
                            endfunction
                            
    1              0.000002 function! s:git_revision(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let head = gitdir . '/HEAD'
                              if empty(gitdir) || !filereadable(head)
                                return ''
                              endif
                            
                              let line = get(readfile(head), 0, '')
                              let ref = matchstr(line, '^ref: \zs.*')
                              if empty(ref)
                                return line
                              endif
                            
                              if filereadable(gitdir . '/' . ref)
                                return get(readfile(gitdir . '/' . ref), 0, '')
                              endif
                            
                              if filereadable(gitdir . '/packed-refs')
                                for line in readfile(gitdir . '/packed-refs')
                                  if line =~# ' ' . ref
                                    return matchstr(line, '^[0-9a-f]*')
                                  endif
                                endfor
                              endif
                            
                              return ''
                            endfunction
                            
    1              0.000002 function! s:git_local_branch(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let head = gitdir . '/HEAD'
                              if empty(gitdir) || !filereadable(head)
                                return ''
                              endif
                              let branch = matchstr(get(readfile(head), 0, ''), '^ref: refs/heads/\zs.*')
                              return len(branch) ? branch : 'HEAD'
                            endfunction
                            
    1              0.000002 function! s:git_origin_branch(spec)
                              if len(a:spec.branch)
                                return a:spec.branch
                              endif
                            
                              " The file may not be present if this is a local repository
                              let gitdir = s:git_dir(a:spec.dir)
                              let origin_head = gitdir.'/refs/remotes/origin/HEAD'
                              if len(gitdir) && filereadable(origin_head)
                                return matchstr(get(readfile(origin_head), 0, ''),
                                              \ '^ref: refs/remotes/origin/\zs.*')
                              endif
                            
                              " The command may not return the name of a branch in detached HEAD state
                              let result = s:lines(s:system('git symbolic-ref --short HEAD', a:spec.dir))
                              return v:shell_error ? '' : result[-1]
                            endfunction
                            
    1              0.000002 if s:is_win
                              function! s:plug_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
    1              0.000001 else
    1              0.000002   function! s:plug_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:plug_getcwd()
                              return s:plug_call('getcwd')
                            endfunction
                            
    1              0.000002 function! s:plug_fnamemodify(fname, mods)
                              return s:plug_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000002 function! s:plug_expand(fmt)
                              return s:plug_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000002 function! s:plug_tempname()
                              return s:plug_call('tempname')
                            endfunction
                            
    1              0.000001 function! plug#begin(...)
                              if a:0 > 0
                                let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif has('nvim')
                                let home = stdpath('data') . '/plugged'
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
                              if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
                              let g:plug_home = home
                              let g:plugs = {}
                              let g:plugs_order = []
                              let s:triggers = {}
                            
                              call s:define_commands()
                              return 1
                            endfunction
                            
    1              0.000002 function! s:define_commands()
                              command! -nargs=+ -bar Plug call plug#(<args>)
                              if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
                              if has('win32')
                              \ && &shellslash
                              \ && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
                                return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
                              endif
                              if !has('nvim')
                                \ && (has('win32') || has('win32unix'))
                                \ && !has('multi_byte')
                                return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
                              endif
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
                              command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
                              command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
                              command! -nargs=0 -bar PlugStatus  call s:status()
                              command! -nargs=0 -bar PlugDiff    call s:diff()
                              command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
                            endfunction
                            
    1              0.000002 function! s:to_a(v)
                              return type(a:v) == s:TYPE.list ? a:v : [a:v]
                            endfunction
                            
    1              0.000003 function! s:to_s(v)
                              return type(a:v) == s:TYPE.string ? a:v : join(a:v, "\n") . "\n"
                            endfunction
                            
    1              0.000002 function! s:glob(from, pattern)
                              return s:lines(globpath(a:from, a:pattern))
                            endfunction
                            
    1              0.000002 function! s:source(from, ...)
                              let found = 0
                              for pattern in a:000
                                for vim in s:glob(a:from, pattern)
                                  execute 'source' s:esc(vim)
                                  let found = 1
                                endfor
                              endfor
                              return found
                            endfunction
                            
    1              0.000002 function! s:assoc(dict, key, val)
                              let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)
                            endfunction
                            
    1              0.000002 function! s:ask(message, ...)
                              call inputsave()
                              echohl WarningMsg
                              let answer = input(a:message.(a:0 ? ' (y/N/a) ' : ' (y/N) '))
                              echohl None
                              call inputrestore()
                              echo "\r"
                              return (a:0 && answer =~? '^a') ? 2 : (answer =~? '^y') ? 1 : 0
                            endfunction
                            
    1              0.000002 function! s:ask_no_interrupt(...)
                              try
                                return call('s:ask', a:000)
                              catch
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! s:lazy(plug, opt)
                              return has_key(a:plug, a:opt) &&
                                    \ (empty(s:to_a(a:plug[a:opt]))         ||
                                    \  !isdirectory(a:plug.dir)             ||
                                    \  len(s:glob(s:rtp(a:plug), 'plugin')) ||
                                    \  len(s:glob(s:rtp(a:plug), 'after/plugin')))
                            endfunction
                            
    1              0.000001 function! plug#end()
                              if !exists('g:plugs')
                                return s:err('plug#end() called without calling plug#begin() first')
                              endif
                            
                              if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
                              let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
                              if get(g:, 'did_load_filetypes', 0)
                                filetype off
                              endif
                              for name in g:plugs_order
                                if !has_key(g:plugs, name)
                                  continue
                                endif
                                let plug = g:plugs[name]
                                if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
                                  let s:loaded[name] = 1
                                  continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd.
                                      \ '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    if has('nvim-0.5.0')
                                      call s:source(s:rtp(plug), 'ftdetect/**/*.lua', 'after/ftdetect/**/*.lua')
                                    endif
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
                              endfor
                            
                              for [cmd, names] in items(lod.cmd)
                                execute printf(
                                \ 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)',
                                \ cmd, string(cmd), string(names))
                              endfor
                            
                              for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in
                                      \ [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf(
                                  \ '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>',
                                  \ mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
                              for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)',
                                        \ ft, string(ft), string(names))
                                augroup END
                              endfor
                            
                              call s:reorg_rtp()
                              filetype plugin indent on
                              if has('vim_starting')
                                if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
                              else
                                call s:reload_plugins()
                              endif
                            endfunction
                            
    1              0.000001 function! s:loaded_names()
                              return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
                            endfunction
                            
    1              0.000001 function! s:load_plugin(spec)
                              call s:source(s:rtp(a:spec), 'plugin/**/*.vim', 'after/plugin/**/*.vim')
                              if has('nvim-0.5.0')
                                call s:source(s:rtp(a:spec), 'plugin/**/*.lua', 'after/plugin/**/*.lua')
                              endif
                            endfunction
                            
    1              0.000001 function! s:reload_plugins()
                              for name in s:loaded_names()
                                call s:load_plugin(g:plugs[name])
                              endfor
                            endfunction
                            
    1              0.000001 function! s:trim(str)
                              return substitute(a:str, '[\/]\+$', '', '')
                            endfunction
                            
    1              0.000001 function! s:version_requirement(val, min)
                              for idx in range(0, len(a:min) - 1)
                                let v = get(a:val, idx, 0)
                                if     v < a:min[idx] | return 0
                                elseif v > a:min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:git_version_requirement(...)
                              if !exists('s:git_version')
                                let s:git_version = map(split(split(s:system(['git', '--version']))[2], '\.'), 'str2nr(v:val)')
                              endif
                              return s:version_requirement(s:git_version, a:000)
                            endfunction
                            
    1              0.000001 function! s:progress_opt(base)
                              return a:base && !s:is_win &&
                                    \ s:git_version_requirement(1, 7, 1) ? '--progress' : ''
                            endfunction
                            
    1              0.000001 function! s:rtp(spec)
                              return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
                            endfunction
                            
    1              0.000001 if s:is_win
                              function! s:path(path)
                                return s:trim(substitute(a:path, '/', '\', 'g'))
                              endfunction
                            
                              function! s:dirpath(path)
                                return s:path(a:path) . '\'
                              endfunction
                            
                              function! s:is_local_plug(repo)
                                return a:repo =~? '^[a-z]:\|^[%~]'
                              endfunction
                            
                              " Copied from fzf
                              function! s:wrap_cmds(cmds)
                                let cmds = [
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal']
                                if has('iconv')
                                  if !exists('s:codepage')
                                    let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                  endif
                                  return map(cmds, printf('iconv(v:val."\r", "%s", "cp%d")', &encoding, s:codepage))
                                endif
                                return map(cmds, 'v:val."\r"')
                              endfunction
                            
                              function! s:batchfile(cmd)
                                let batchfile = s:plug_tempname().'.bat'
                                call writefile(s:wrap_cmds(a:cmd), batchfile)
                                let cmd = plug#shellescape(batchfile, {'shell': &shell, 'script': 0})
                                if s:is_powershell(&shell)
                                  let cmd = '& ' . cmd
                                endif
                                return [batchfile, cmd]
                              endfunction
    1              0.000000 else
    1              0.000001   function! s:path(path)
                                return s:trim(a:path)
                              endfunction
                            
    1              0.000001   function! s:dirpath(path)
                                return substitute(a:path, '[/\\]*$', '/', '')
                              endfunction
                            
    1              0.000001   function! s:is_local_plug(repo)
                                return a:repo[0] =~ '[/$~]'
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:err(msg)
                              echohl ErrorMsg
                              echom '[vim-plug] '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(cmd, msg)
                              echohl WarningMsg
                              execute a:cmd 'a:msg'
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:esc(path)
                              return escape(a:path, ' ')
                            endfunction
                            
    1              0.000001 function! s:escrtp(path)
                              return escape(a:path, ' ,')
                            endfunction
                            
    1              0.000001 function! s:remove_rtp()
                              for name in s:loaded_names()
                                let rtp = s:rtp(g:plugs[name])
                                execute 'set rtp-='.s:escrtp(rtp)
                                let after = globpath(rtp, 'after')
                                if isdirectory(after)
                                  execute 'set rtp-='.s:escrtp(after)
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:reorg_rtp()
                              if !empty(s:first_rtp)
                                execute 'set rtp-='.s:first_rtp
                                execute 'set rtp-='.s:last_rtp
                              endif
                            
                              " &rtp is modified from outside
                              if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
                              let s:middle = get(s:, 'middle', &rtp)
                              let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
                              let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
                              let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',')
                                             \ . ','.s:middle.','
                                             \ . join(map(afters, 'escape(v:val, ",")'), ',')
                              let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
                              let s:prtp   = &rtp
                            
                              if !empty(s:first_rtp)
                                execute 'set rtp^='.s:first_rtp
                                execute 'set rtp+='.s:last_rtp
                              endif
                            endfunction
                            
    1              0.000001 function! s:doautocmd(...)
                              if exists('#'.join(a:000, '#'))
                                execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
                              endif
                            endfunction
                            
    1              0.000001 function! s:dobufread(names)
                              for name in a:names
                                let path = s:rtp(g:plugs[name])
                                for dir in ['ftdetect', 'ftplugin', 'after/ftdetect', 'after/ftplugin']
                                  if len(finddir(dir, path))
                                    if exists('#BufRead')
                                      doautocmd BufRead
                                    endif
                                    return
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000001 function! plug#load(...)
                              if a:0 == 0
                                return s:err('Argument missing: plugin name(s) required')
                              endif
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              let names = a:0 == 1 && type(a:1) == s:TYPE.list ? a:1 : a:000
                              let unknowns = filter(copy(names), '!has_key(g:plugs, v:val)')
                              if !empty(unknowns)
                                let s = len(unknowns) > 1 ? 's' : ''
                                return s:err(printf('Unknown plugin%s: %s', s, join(unknowns, ', ')))
                              end
                              let unloaded = filter(copy(names), '!get(s:loaded, v:val, 0)')
                              if !empty(unloaded)
                                for name in unloaded
                                  call s:lod([name], ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                                endfor
                                call s:dobufread(unloaded)
                                return 1
                              end
                              return 0
                            endfunction
                            
    1              0.000001 function! s:remove_triggers(name)
                              if !has_key(s:triggers, a:name)
                                return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)
                            endfunction
                            
    1              0.000001 function! s:lod(names, types, ...)
                              for name in a:names
                                call s:remove_triggers(name)
                                let s:loaded[name] = 1
                              endfor
                              call s:reorg_rtp()
                            
                              for name in a:names
                                let rtp = s:rtp(g:plugs[name])
                                for dir in a:types
                                  call s:source(rtp, dir.'/**/*.vim')
                                  if has('nvim-0.5.0')  " see neovim#14686
                                    call s:source(rtp, dir.'/**/*.lua')
                                  endif
                                endfor
                                if a:0
                                  if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
                                  call s:source(rtp, a:2)
                                endif
                                call s:doautocmd('User', name)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:lod_ft(pat, names)
                              let syn = 'syntax/'.a:pat.'.vim'
                              call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
                              execute 'autocmd! PlugLOD FileType' a:pat
                              call s:doautocmd('filetypeplugin', 'FileType')
                              call s:doautocmd('filetypeindent', 'FileType')
                            endfunction
                            
    1              0.000001 function! s:lod_cmd(cmd, bang, l1, l2, args, names)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              execute printf('%s%s%s %s', (a:l1 == a:l2 ? '' : (a:l1.','.a:l2)), a:cmd, a:bang, a:args)
                            endfunction
                            
    1              0.000001 function! s:lod_map(map, names, with_prefix, prefix)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              let extra = ''
                              while 1
                                let c = getchar(0)
                                if c == 0
                                  break
                                endif
                                let extra .= nr2char(c)
                              endwhile
                            
                              if a:with_prefix
                                let prefix = v:count ? v:count : ''
                                let prefix .= '"'.v:register.a:prefix
                                if mode(1) == 'no'
                                  if v:operator == 'c'
                                    let prefix = "\<esc>" . prefix
                                  endif
                                  let prefix .= v:operator
                                endif
                                call feedkeys(prefix, 'n')
                              endif
                              call feedkeys(substitute(a:map, '^<Plug>', "\<Plug>", '') . extra)
                            endfunction
                            
    1              0.000001 function! plug#(repo, ...)
                              if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
                              try
                                let repo = s:trim(a:repo)
                                let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
                                let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
                                let spec = extend(s:infer_properties(name, repo), opts)
                                if !has_key(g:plugs, name)
                                  call add(g:plugs_order, name)
                                endif
                                let g:plugs[name] = spec
                                let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(repo . ' ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:parse_options(arg)
                              let opts = copy(s:base_spec)
                              let type = type(a:arg)
                              let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
                              if type == s:TYPE.string
                                if empty(a:arg)
                                  throw printf(opt_errfmt, 'tag', 'string')
                                endif
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
                                for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
                                  if has_key(a:arg, opt)
                                  \ && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string')
                                  endif
                                endfor
                                for opt in ['on', 'for']
                                  if has_key(a:arg, opt)
                                  \ && type(a:arg[opt]) != s:TYPE.list
                                  \ && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string or list')
                                  endif
                                endfor
                                if has_key(a:arg, 'do')
                                  \ && type(a:arg.do) != s:TYPE.funcref
                                  \ && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
                                    throw printf(opt_errfmt, 'do', 'string or funcref')
                                endif
                                call extend(opts, a:arg)
                                if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(s:plug_expand(opts.dir))
                                endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
                              return opts
                            endfunction
                            
    1              0.000001 function! s:infer_properties(name, repo)
                              let repo = a:repo
                              if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(s:plug_expand(repo)) }
                              else
                                if repo =~ ':'
                                  let uri = repo
                                else
                                  if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
                                  let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
                                  let uri = printf(fmt, repo)
                                endif
                                return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif
                            endfunction
                            
    1              0.000001 function! s:install(force, names)
                              call s:update_impl(0, a:force, a:names)
                            endfunction
                            
    1              0.000001 function! s:update(force, names)
                              call s:update_impl(1, a:force, a:names)
                            endfunction
                            
    1              0.000001 function! plug#helptags()
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              for spec in values(g:plugs)
                                let docd = join([s:rtp(spec), 'doc'], '/')
                                if isdirectory(docd)
                                  silent! execute 'helptags' s:esc(docd)
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:syntax()
                              syntax clear
                              syntax region plug1 start=/\%1l/ end=/\%2l/ contains=plugNumber
                              syntax region plug2 start=/\%2l/ end=/\%3l/ contains=plugBracket,plugX
                              syn match plugNumber /[0-9]\+[0-9.]*/ contained
                              syn match plugBracket /[[\]]/ contained
                              syn match plugX /x/ contained
                              syn match plugDash /^-\{1}\ /
                              syn match plugPlus /^+/
                              syn match plugStar /^*/
                              syn match plugMessage /\(^- \)\@<=.*/
                              syn match plugName /\(^- \)\@<=[^ ]*:/
                              syn match plugSha /\%(: \)\@<=[0-9a-f]\{4,}$/
                              syn match plugTag /(tag: [^)]\+)/
                              syn match plugInstall /\(^+ \)\@<=[^:]*/
                              syn match plugUpdate /\(^* \)\@<=[^:]*/
                              syn match plugCommit /^  \X*[0-9a-f]\{7,9} .*/ contains=plugRelDate,plugEdge,plugTag
                              syn match plugEdge /^  \X\+$/
                              syn match plugEdge /^  \X*/ contained nextgroup=plugSha
                              syn match plugSha /[0-9a-f]\{7,9}/ contained
                              syn match plugRelDate /([^)]*)$/ contained
                              syn match plugNotLoaded /(not loaded)$/
                              syn match plugError /^x.*/
                              syn region plugDeleted start=/^\~ .*/ end=/^\ze\S/
                              syn match plugH2 /^.*:\n-\+$/
                              syn match plugH2 /^-\{2,}/
                              syn keyword Function PlugInstall PlugStatus PlugUpdate PlugClean
                              hi def link plug1       Title
                              hi def link plug2       Repeat
                              hi def link plugH2      Type
                              hi def link plugX       Exception
                              hi def link plugBracket Structure
                              hi def link plugNumber  Number
                            
                              hi def link plugDash    Special
                              hi def link plugPlus    Constant
                              hi def link plugStar    Boolean
                            
                              hi def link plugMessage Function
                              hi def link plugName    Label
                              hi def link plugInstall Function
                              hi def link plugUpdate  Type
                            
                              hi def link plugError   Error
                              hi def link plugDeleted Ignore
                              hi def link plugRelDate Comment
                              hi def link plugEdge    PreProc
                              hi def link plugSha     Identifier
                              hi def link plugTag     Constant
                            
                              hi def link plugNotLoaded Comment
                            endfunction
                            
    1              0.000001 function! s:lpad(str, len)
                              return a:str . repeat(' ', a:len - len(a:str))
                            endfunction
                            
    1              0.000001 function! s:lines(msg)
                              return split(a:msg, "[\r\n]")
                            endfunction
                            
    1              0.000001 function! s:lastline(msg)
                              return get(s:lines(a:msg), -1, '')
                            endfunction
                            
    1              0.000001 function! s:new_window()
                              execute get(g:, 'plug_window', '-tabnew')
                            endfunction
                            
    1              0.000001 function! s:plug_window_exists()
                              let buflist = tabpagebuflist(s:plug_tab)
                              return !empty(buflist) && index(buflist, s:plug_buf) >= 0
                            endfunction
                            
    1              0.000002 function! s:switch_in()
                              if !s:plug_window_exists()
                                return 0
                              endif
                            
                              if winbufnr(0) != s:plug_buf
                                let s:pos = [tabpagenr(), winnr(), winsaveview()]
                                execute 'normal!' s:plug_tab.'gt'
                                let winnr = bufwinnr(s:plug_buf)
                                execute winnr.'wincmd w'
                                call add(s:pos, winsaveview())
                              else
                                let s:pos = [winsaveview()]
                              endif
                            
                              setlocal modifiable
                              return 1
                            endfunction
                            
    1              0.000001 function! s:switch_out(...)
                              call winrestview(s:pos[-1])
                              setlocal nomodifiable
                              if a:0 > 0
                                execute a:1
                              endif
                            
                              if len(s:pos) > 1
                                execute 'normal!' s:pos[0].'gt'
                                execute s:pos[1] 'wincmd w'
                                call winrestview(s:pos[2])
                              endif
                            endfunction
                            
    1              0.000001 function! s:finish_bindings()
                              nnoremap <silent> <buffer> R  :call <SID>retry()<cr>
                              nnoremap <silent> <buffer> D  :PlugDiff<cr>
                              nnoremap <silent> <buffer> S  :PlugStatus<cr>
                              nnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              xnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              nnoremap <silent> <buffer> ]] :silent! call <SID>section('')<cr>
                              nnoremap <silent> <buffer> [[ :silent! call <SID>section('b')<cr>
                            endfunction
                            
    1              0.000001 function! s:prepare(...)
                              if empty(s:plug_getcwd())
                                throw 'Invalid current working directory. Cannot proceed.'
                              endif
                            
                              for evar in ['$GIT_DIR', '$GIT_WORK_TREE']
                                if exists(evar)
                                  throw evar.' detected. Cannot proceed.'
                                endif
                              endfor
                            
                              call s:job_abort()
                              if s:switch_in()
                                if b:plug_preview == 1
                                  pc
                                endif
                                enew
                              else
                                call s:new_window()
                              endif
                            
                              nnoremap <silent> <buffer> q :call <SID>close_pane()<cr>
                              if a:0 == 0
                                call s:finish_bindings()
                              endif
                              let b:plug_preview = -1
                              let s:plug_tab = tabpagenr()
                              let s:plug_buf = winbufnr(0)
                              call s:assign_name()
                            
                              for k in ['<cr>', 'L', 'o', 'X', 'd', 'dd']
                                execute 'silent! unmap <buffer>' k
                              endfor
                              setlocal buftype=nofile bufhidden=wipe nobuflisted nolist noswapfile nowrap cursorline modifiable nospell
                              if exists('+colorcolumn')
                                setlocal colorcolumn=
                              endif
                              setf vim-plug
                              if exists('g:syntax_on')
                                call s:syntax()
                              endif
                            endfunction
                            
    1              0.000001 function! s:close_pane()
                              if b:plug_preview == 1
                                pc
                                let b:plug_preview = -1
                              else
                                bd
                              endif
                            endfunction
                            
    1              0.000001 function! s:assign_name()
                              " Assign buffer name
                              let prefix = '[Plugins]'
                              let name   = prefix
                              let idx    = 2
                              while bufexists(name)
                                let name = printf('%s (%s)', prefix, idx)
                                let idx = idx + 1
                              endwhile
                              silent! execute 'f' fnameescape(name)
                            endfunction
                            
    1              0.000001 function! s:chsh(swap)
                              let prev = [&shell, &shellcmdflag, &shellredir]
                              if !s:is_win
                                set shell=sh
                              endif
                              if a:swap
                                if s:is_powershell(&shell)
                                  let &shellredir = '2>&1 | Out-File -Encoding UTF8 %s'
                                elseif &shell =~# 'sh' || &shell =~# 'cmd\(\.exe\)\?$'
                                  set shellredir=>%s\ 2>&1
                                endif
                              endif
                              return prev
                            endfunction
                            
    1              0.000001 function! s:bang(cmd, ...)
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(a:0)
                                " FIXME: Escaping is incomplete. We could use shellescape with eval,
                                "        but it won't work on Windows.
                                let cmd = a:0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                if s:is_win
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                let g:_plug_bang = (s:is_win && has('gui_running') ? 'silent ' : '').'!'.escape(cmd, '#!%')
                                execute "normal! :execute g:_plug_bang\<cr>\<cr>"
                              finally
                                unlet g:_plug_bang
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                              return v:shell_error ? 'Exit status: ' . v:shell_error : ''
                            endfunction
                            
    1              0.000001 function! s:regress_bar()
                              let bar = substitute(getline(2)[1:-2], '.*\zs=', 'x', '')
                              call s:progress_bar(2, bar, len(bar))
                            endfunction
                            
    1              0.000001 function! s:is_updated(dir)
                              return !empty(s:system_chomp(['git', 'log', '--pretty=format:%h', 'HEAD...HEAD@{1}'], a:dir))
                            endfunction
                            
    1              0.000001 function! s:do(pull, force, todo)
                              if has('nvim')
                                " Reset &rtp to invalidate Neovim cache of loaded Lua modules
                                " See https://github.com/junegunn/vim-plug/pull/1157#issuecomment-1809226110
                                let &rtp = &rtp
                              endif
                              for [name, spec] in items(a:todo)
                                if !isdirectory(spec.dir)
                                  continue
                                endif
                                let installed = has_key(s:update.new, name)
                                let updated = installed ? 0 :
                                  \ (a:pull && index(s:update.errors, name) < 0 && s:is_updated(spec.dir))
                                if a:force || installed || updated
                                  execute 'cd' s:esc(spec.dir)
                                  call append(3, '- Post-update hook for '. name .' ... ')
                                  let error = ''
                                  let type = type(spec.do)
                                  if type == s:TYPE.string
                                    if spec.do[0] == ':'
                                      if !get(s:loaded, name, 0)
                                        let s:loaded[name] = 1
                                        call s:reorg_rtp()
                                      endif
                                      call s:load_plugin(spec)
                                      try
                                        execute spec.do[1:]
                                      catch
                                        let error = v:exception
                                      endtry
                                      if !s:plug_window_exists()
                                        cd -
                                        throw 'Warning: vim-plug was terminated by the post-update hook of '.name
                                      endif
                                    else
                                      let error = s:bang(spec.do)
                                    endif
                                  elseif type == s:TYPE.funcref
                                    try
                                      call s:load_plugin(spec)
                                      let status = installed ? 'installed' : (updated ? 'updated' : 'unchanged')
                                      call spec.do({ 'name': name, 'status': status, 'force': a:force })
                                    catch
                                      let error = v:exception
                                    endtry
                                  else
                                    let error = 'Invalid hook type'
                                  endif
                                  call s:switch_in()
                                  call setline(4, empty(error) ? (getline(4) . 'OK')
                                                             \ : ('x' . getline(4)[1:] . error))
                                  if !empty(error)
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                  endif
                                  cd -
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:hash_match(a, b)
                              return stridx(a:a, a:b) == 0 || stridx(a:b, a:a) == 0
                            endfunction
                            
    1              0.000001 function! s:checkout(spec)
                              let sha = a:spec.commit
                              let output = s:git_revision(a:spec.dir)
                              let error = 0
                              if !empty(output) && !s:hash_match(sha, s:lines(output)[0])
                                let credential_helper = s:git_version_requirement(2) ? '-c credential.helper= ' : ''
                                let output = s:system(
                                      \ 'git '.credential_helper.'fetch --depth 999999 && git checkout '.plug#shellescape(sha).' --', a:spec.dir)
                                let error = v:shell_error
                              endif
                              return [output, error]
                            endfunction
                            
    1              0.000001 function! s:finish(pull)
                              let new_frozen = len(filter(keys(s:update.new), 'g:plugs[v:val].frozen'))
                              if new_frozen
                                let s = new_frozen > 1 ? 's' : ''
                                call append(3, printf('- Installed %d frozen plugin%s', new_frozen, s))
                              endif
                              call append(3, '- Finishing ... ') | 4
                              redraw
                              call plug#helptags()
                              call plug#end()
                              call setline(4, getline(4) . 'Done!')
                              redraw
                              let msgs = []
                              if !empty(s:update.errors)
                                call add(msgs, "Press 'R' to retry.")
                              endif
                              if a:pull && len(s:update.new) < len(filter(getline(5, '$'),
                                            \ "v:val =~ '^- ' && v:val !~# 'Already up.to.date'"))
                                call add(msgs, "Press 'D' to see the updated changes.")
                              endif
                              echo join(msgs, ' ')
                              call s:finish_bindings()
                            endfunction
                            
    1              0.000001 function! s:retry()
                              if empty(s:update.errors)
                                return
                              endif
                              echo
                              call s:update_impl(s:update.pull, s:update.force,
                                    \ extend(copy(s:update.errors), [s:update.threads]))
                            endfunction
                            
    1              0.000001 function! s:is_managed(name)
                              return has_key(g:plugs[a:name], 'uri')
                            endfunction
                            
    1              0.000001 function! s:names(...)
                              return sort(filter(keys(g:plugs), 'stridx(v:val, a:1) == 0 && s:is_managed(v:val)'))
                            endfunction
                            
    1              0.000001 function! s:check_ruby()
                              silent! ruby require 'thread'; VIM::command("let g:plug_ruby = '#{RUBY_VERSION}'")
                              if !exists('g:plug_ruby')
                                redraw!
                                return s:warn('echom', 'Warning: Ruby interface is broken')
                              endif
                              let ruby_version = split(g:plug_ruby, '\.')
                              unlet g:plug_ruby
                              return s:version_requirement(ruby_version, [1, 8, 7])
                            endfunction
                            
    1              0.000001 function! s:update_impl(pull, force, args) abort
                              let sync = index(a:args, '--sync') >= 0 || has('vim_starting')
                              let args = filter(copy(a:args), 'v:val != "--sync"')
                              let threads = (len(args) > 0 && args[-1] =~ '^[1-9][0-9]*$') ?
                                              \ remove(args, -1) : get(g:, 'plug_threads', 16)
                            
                              let managed = filter(deepcopy(g:plugs), 's:is_managed(v:key)')
                              let todo = empty(args) ? filter(managed, '!v:val.frozen || !isdirectory(v:val.dir)') :
                                                     \ filter(managed, 'index(args, v:key) >= 0')
                            
                              if empty(todo)
                                return s:warn('echo', 'No plugin to '. (a:pull ? 'update' : 'install'))
                              endif
                            
                              if !s:is_win && s:git_version_requirement(2, 3)
                                let s:git_terminal_prompt = exists('$GIT_TERMINAL_PROMPT') ? $GIT_TERMINAL_PROMPT : ''
                                let $GIT_TERMINAL_PROMPT = 0
                                for plug in values(todo)
                                  let plug.uri = substitute(plug.uri,
                                        \ '^https://git::@github\.com', 'https://github.com', '')
                                endfor
                              endif
                            
                              if !isdirectory(g:plug_home)
                                try
                                  call mkdir(g:plug_home, 'p')
                                catch
                                  return s:err(printf('Invalid plug directory: %s. '.
                                          \ 'Try to call plug#begin with a valid directory', g:plug_home))
                                endtry
                              endif
                            
                              if has('nvim') && !exists('*jobwait') && threads > 1
                                call s:warn('echom', '[vim-plug] Update Neovim for parallel installer')
                              endif
                            
                              let use_job = s:nvim || s:vim8
                              let python = (has('python') || has('python3')) && !use_job
                              let ruby = has('ruby') && !use_job && (v:version >= 703 || v:version == 702 && has('patch374')) && !(s:is_win && has('gui_running')) && threads > 1 && s:check_ruby()
                            
                              let s:update = {
                                \ 'start':   reltime(),
                                \ 'all':     todo,
                                \ 'todo':    copy(todo),
                                \ 'errors':  [],
                                \ 'pull':    a:pull,
                                \ 'force':   a:force,
                                \ 'new':     {},
                                \ 'threads': (python || ruby || use_job) ? min([len(todo), threads]) : 1,
                                \ 'bar':     '',
                                \ 'fin':     0
                              \ }
                            
                              call s:prepare(1)
                              call append(0, ['', ''])
                              normal! 2G
                              silent! redraw
                            
                              " Set remote name, overriding a possible user git config's clone.defaultRemoteName
                              let s:clone_opt = ['--origin', 'origin']
                              if get(g:, 'plug_shallow', 1)
                                call extend(s:clone_opt, ['--depth', '1'])
                                if s:git_version_requirement(1, 7, 10)
                                  call add(s:clone_opt, '--no-single-branch')
                                endif
                              endif
                            
                              if has('win32unix') || has('wsl')
                                call extend(s:clone_opt, ['-c', 'core.eol=lf', '-c', 'core.autocrlf=input'])
                              endif
                            
                              let s:submodule_opt = s:git_version_requirement(2, 8) ? ' --jobs='.threads : ''
                            
                              " Python version requirement (>= 2.7)
                              if python && !has('python3') && !ruby && !use_job && s:update.threads > 1
                                redir => pyv
                                silent python import platform; print platform.python_version()
                                redir END
                                let python = s:version_requirement(
                                      \ map(split(split(pyv)[0], '\.'), 'str2nr(v:val)'), [2, 6])
                              endif
                            
                              if (python || ruby) && s:update.threads > 1
                                try
                                  let imd = &imd
                                  if s:mac_gui
                                    set noimd
                                  endif
                                  if ruby
                                    call s:update_ruby()
                                  else
                                    call s:update_python()
                                  endif
                                catch
                                  let lines = getline(4, '$')
                                  let printed = {}
                                  silent! 4,$d _
                                  for line in lines
                                    let name = s:extract_name(line, '.', '')
                                    if empty(name) || !has_key(printed, name)
                                      call append('$', line)
                                      if !empty(name)
                                        let printed[name] = 1
                                        if line[0] == 'x' && index(s:update.errors, name) < 0
                                          call add(s:update.errors, name)
                                        end
                                      endif
                                    endif
                                  endfor
                                finally
                                  let &imd = imd
                                  call s:update_finish()
                                endtry
                              else
                                call s:update_vim()
                                while use_job && sync
                                  sleep 100m
                                  if s:update.fin
                                    break
                                  endif
                                endwhile
                              endif
                            endfunction
                            
    1              0.000001 function! s:log4(name, msg)
                              call setline(4, printf('- %s (%s)', a:msg, a:name))
                              redraw
                            endfunction
                            
    1              0.000001 function! s:update_finish()
                              if exists('s:git_terminal_prompt')
                                let $GIT_TERMINAL_PROMPT = s:git_terminal_prompt
                              endif
                              if s:switch_in()
                                call append(3, '- Updating ...') | 4
                                for [name, spec] in items(filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && (s:update.force || s:update.pull || has_key(s:update.new, v:key))'))
                                  let [pos, _] = s:logpos(name)
                                  if !pos
                                    continue
                                  endif
                                  let out = ''
                                  let error = 0
                                  if has_key(spec, 'commit')
                                    call s:log4(name, 'Checking out '.spec.commit)
                                    let [out, error] = s:checkout(spec)
                                  elseif has_key(spec, 'tag')
                                    let tag = spec.tag
                                    if tag =~ '\*'
                                      let tags = s:lines(s:system('git tag --list '.plug#shellescape(tag).' --sort -version:refname 2>&1', spec.dir))
                                      if !v:shell_error && !empty(tags)
                                        let tag = tags[0]
                                        call s:log4(name, printf('Latest tag for %s -> %s', spec.tag, tag))
                                        call append(3, '')
                                      endif
                                    endif
                                    call s:log4(name, 'Checking out '.tag)
                                    let out = s:system('git checkout -q '.plug#shellescape(tag).' -- 2>&1', spec.dir)
                                    let error = v:shell_error
                                  endif
                                  if !error && filereadable(spec.dir.'/.gitmodules') &&
                                        \ (s:update.force || has_key(s:update.new, name) || s:is_updated(spec.dir))
                                    call s:log4(name, 'Updating submodules. This may take a while.')
                                    let out .= s:bang('git submodule update --init --recursive'.s:submodule_opt.' 2>&1', spec.dir)
                                    let error = v:shell_error
                                  endif
                                  let msg = s:format_message(v:shell_error ? 'x': '-', name, out)
                                  if error
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                    silent execute pos 'd _'
                                    call append(4, msg) | 4
                                  elseif !empty(out)
                                    call setline(pos, msg[0])
                                  endif
                                  redraw
                                endfor
                                silent 4 d _
                                try
                                  call s:do(s:update.pull, s:update.force, filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && has_key(v:val, "do")'))
                                catch
                                  call s:warn('echom', v:exception)
                                  call s:warn('echo', '')
                                  return
                                endtry
                                call s:finish(s:update.pull)
                                call setline(1, 'Updated. Elapsed time: ' . split(reltimestr(reltime(s:update.start)))[0] . ' sec.')
                                call s:switch_out('normal! gg')
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_abort()
                              if (!s:nvim && !s:vim8) || !exists('s:jobs')
                                return
                              endif
                            
                              for [name, j] in items(s:jobs)
                                if s:nvim
                                  silent! call jobstop(j.jobid)
                                elseif s:vim8
                                  silent! call job_stop(j.jobid)
                                endif
                                if j.new
                                  call s:rm_rf(g:plugs[name].dir)
                                endif
                              endfor
                              let s:jobs = {}
                            endfunction
                            
    1              0.000001 function! s:last_non_empty_line(lines)
                              let len = len(a:lines)
                              for idx in range(len)
                                let line = a:lines[len-idx-1]
                                if !empty(line)
                                  return line
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:job_out_cb(self, data) abort
                              let self = a:self
                              let data = remove(self.lines, -1) . a:data
                              let lines = map(split(data, "\n", 1), 'split(v:val, "\r", 1)[-1]')
                              call extend(self.lines, lines)
                              " To reduce the number of buffer updates
                              let self.tick = get(self, 'tick', -1) + 1
                              if !self.running || self.tick % len(s:jobs) == 0
                                let bullet = self.running ? (self.new ? '+' : '*') : (self.error ? 'x' : '-')
                                let result = self.error ? join(self.lines, "\n") : s:last_non_empty_line(self.lines)
                                if len(result)
                                  call s:log(bullet, self.name, result)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_exit_cb(self, data) abort
                              let a:self.running = 0
                              let a:self.error = a:data != 0
                              call s:reap(a:self.name)
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:job_cb(fn, job, ch, data)
                              if !s:plug_window_exists() " plug window closed
                                return s:job_abort()
                              endif
                              call call(a:fn, [a:job, a:data])
                            endfunction
                            
    1              0.000001 function! s:nvim_cb(job_id, data, event) dict abort
                              return (a:event == 'stdout' || a:event == 'stderr') ?
                                \ s:job_cb('s:job_out_cb',  self, 0, join(a:data, "\n")) :
                                \ s:job_cb('s:job_exit_cb', self, 0, a:data)
                            endfunction
                            
    1              0.000001 function! s:spawn(name, spec, queue, opts)
                              let job = { 'name': a:name, 'spec': a:spec, 'running': 1, 'error': 0, 'lines': [''],
                                        \ 'new': get(a:opts, 'new', 0), 'queue': copy(a:queue) }
                              let Item = remove(job.queue, 0)
                              let argv = type(Item) == s:TYPE.funcref ? call(Item, [a:spec]) : Item
                              let s:jobs[a:name] = job
                            
                              if s:nvim
                                if has_key(a:opts, 'dir')
                                  let job.cwd = a:opts.dir
                                endif
                                call extend(job, {
                                \ 'on_stdout': function('s:nvim_cb'),
                                \ 'on_stderr': function('s:nvim_cb'),
                                \ 'on_exit':   function('s:nvim_cb'),
                                \ })
                                let jid = s:plug_call('jobstart', argv, job)
                                if jid > 0
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = [jid < 0 ? argv[0].' is not executable' :
                                        \ 'Invalid arguments (or job table is full)']
                                endif
                              elseif s:vim8
                                let cmd = join(map(copy(argv), 'plug#shellescape(v:val, {"script": 0})'))
                                if has_key(a:opts, 'dir')
                                  let cmd = s:with_cd(cmd, a:opts.dir, 0)
                                endif
                                let argv = s:is_win ? ['cmd', '/s', '/c', '"'.cmd.'"'] : ['sh', '-c', cmd]
                                let jid = job_start(s:is_win ? join(argv, ' ') : argv, {
                                \ 'out_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'err_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'exit_cb':  function('s:job_cb', ['s:job_exit_cb', job]),
                                \ 'err_mode': 'raw',
                                \ 'out_mode': 'raw'
                                \})
                                if job_status(jid) == 'run'
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = ['Failed to start job']
                                endif
                              else
                                let job.lines = s:lines(call('s:system', has_key(a:opts, 'dir') ? [argv, a:opts.dir] : [argv]))
                                let job.error = v:shell_error != 0
                                let job.running = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:reap(name)
                              let job = remove(s:jobs, a:name)
                              if job.error
                                call add(s:update.errors, a:name)
                              elseif get(job, 'new', 0)
                                let s:update.new[a:name] = 1
                              endif
                            
                              let more = len(get(job, 'queue', []))
                              let bullet = job.error ? 'x' : more ? (job.new ? '+' : '*') : '-'
                              let result = job.error ? join(job.lines, "\n") : s:last_non_empty_line(job.lines)
                              if len(result)
                                call s:log(bullet, a:name, result)
                              endif
                            
                              if !job.error && more
                                let job.spec.queue = job.queue
                                let s:update.todo[a:name] = job.spec
                              else
                                let s:update.bar .= job.error ? 'x' : '='
                                call s:bar()
                              endif
                            endfunction
                            
    1              0.000001 function! s:bar()
                              if s:switch_in()
                                let total = len(s:update.all)
                                call setline(1, (s:update.pull ? 'Updating' : 'Installing').
                                      \ ' plugins ('.len(s:update.bar).'/'.total.')')
                                call s:progress_bar(2, s:update.bar, total)
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:logpos(name)
                              let max = line('$')
                              for i in range(4, max > 4 ? max : 4)
                                if getline(i) =~# '^[-+x*] '.a:name.':'
                                  for j in range(i + 1, max > 5 ? max : 5)
                                    if getline(j) !~ '^ '
                                      return [i, j - 1]
                                    endif
                                  endfor
                                  return [i, i]
                                endif
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000001 function! s:log(bullet, name, lines)
                              if s:switch_in()
                                let [b, e] = s:logpos(a:name)
                                if b > 0
                                  silent execute printf('%d,%d d _', b, e)
                                  if b > winheight('.')
                                    let b = 4
                                  endif
                                else
                                  let b = 4
                                endif
                                " FIXME For some reason, nomodifiable is set after :d in vim8
                                setlocal modifiable
                                call append(b - 1, s:format_message(a:bullet, a:name, a:lines))
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:update_vim()
                              let s:jobs = {}
                            
                              call s:bar()
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:checkout_command(spec)
                              let a:spec.branch = s:git_origin_branch(a:spec)
                              return ['git', 'checkout', '-q', a:spec.branch, '--']
                            endfunction
                            
    1              0.000001 function! s:merge_command(spec)
                              let a:spec.branch = s:git_origin_branch(a:spec)
                              return ['git', 'merge', '--ff-only', 'origin/'.a:spec.branch]
                            endfunction
                            
    1              0.000001 function! s:tick()
                              let pull = s:update.pull
                              let prog = s:progress_opt(s:nvim || s:vim8)
                            while 1 " Without TCO, Vim stack is bound to explode
                              if empty(s:update.todo)
                                if empty(s:jobs) && !s:update.fin
                                  call s:update_finish()
                                  let s:update.fin = 1
                                endif
                                return
                              endif
                            
                              let name = keys(s:update.todo)[0]
                              let spec = remove(s:update.todo, name)
                              let queue = get(spec, 'queue', [])
                              let new = empty(globpath(spec.dir, '.git', 1))
                            
                              if empty(queue)
                                call s:log(new ? '+' : '*', name, pull ? 'Updating ...' : 'Installing ...')
                                redraw
                              endif
                            
                              let has_tag = has_key(spec, 'tag')
                              if len(queue)
                                call s:spawn(name, spec, queue, { 'dir': spec.dir })
                              elseif !new
                                let [error, _] = s:git_validate(spec, 0)
                                if empty(error)
                                  if pull
                                    let cmd = s:git_version_requirement(2) ? ['git', '-c', 'credential.helper=', 'fetch'] : ['git', 'fetch']
                                    if has_tag && !empty(globpath(spec.dir, '.git/shallow'))
                                      call extend(cmd, ['--depth', '99999999'])
                                    endif
                                    if !empty(prog)
                                      call add(cmd, prog)
                                    endif
                                    let queue = [cmd, split('git remote set-head origin -a')]
                                    if !has_tag && !has_key(spec, 'commit')
                                      call extend(queue, [function('s:checkout_command'), function('s:merge_command')])
                                    endif
                                    call s:spawn(name, spec, queue, { 'dir': spec.dir })
                                  else
                                    let s:jobs[name] = { 'running': 0, 'lines': ['Already installed'], 'error': 0 }
                                  endif
                                else
                                  let s:jobs[name] = { 'running': 0, 'lines': s:lines(error), 'error': 1 }
                                endif
                              else
                                let cmd = ['git', 'clone']
                                if !has_tag
                                  call extend(cmd, s:clone_opt)
                                endif
                                if !empty(prog)
                                  call add(cmd, prog)
                                endif
                                call s:spawn(name, spec, [extend(cmd, [spec.uri, s:trim(spec.dir)]), function('s:checkout_command'), function('s:merge_command')], { 'new': 1 })
                              endif
                            
                              if !s:jobs[name].running
                                call s:reap(name)
                              endif
                              if len(s:jobs) >= s:update.threads
                                break
                              endif
                            endwhile
                            endfunction
                            
    1              0.000001 function! s:update_python()
                            let py_exe = has('python') ? 'python' : 'python3'
                            execute py_exe "<< EOF"
                            import datetime
                            import functools
                            import os
                            try:
                              import queue
                            except ImportError:
                              import Queue as queue
                            import random
                            import re
                            import shutil
                            import signal
                            import subprocess
                            import tempfile
                            import threading as thr
                            import time
                            import traceback
                            import vim
                            
                            G_NVIM = vim.eval("has('nvim')") == '1'
                            G_PULL = vim.eval('s:update.pull') == '1'
                            G_RETRIES = int(vim.eval('get(g:, "plug_retries", 2)')) + 1
                            G_TIMEOUT = int(vim.eval('get(g:, "plug_timeout", 60)'))
                            G_CLONE_OPT = ' '.join(vim.eval('s:clone_opt'))
                            G_PROGRESS = vim.eval('s:progress_opt(1)')
                            G_LOG_PROB = 1.0 / int(vim.eval('s:update.threads'))
                            G_STOP = thr.Event()
                            G_IS_WIN = vim.eval('s:is_win') == '1'
                            
                            class PlugError(Exception):
                              def __init__(self, msg):
                                self.msg = msg
                            class CmdTimedOut(PlugError):
                              pass
                            class CmdFailed(PlugError):
                              pass
                            class InvalidURI(PlugError):
                              pass
                            class Action(object):
                              INSTALL, UPDATE, ERROR, DONE = ['+', '*', 'x', '-']
                            
                            class Buffer(object):
                              def __init__(self, lock, num_plugs, is_pull):
                                self.bar = ''
                                self.event = 'Updating' if is_pull else 'Installing'
                                self.lock = lock
                                self.maxy = int(vim.eval('winheight(".")'))
                                self.num_plugs = num_plugs
                            
                              def __where(self, name):
                                """ Find first line with name in current buffer. Return line num. """
                                found, lnum = False, 0
                                matcher = re.compile('^[-+x*] {0}:'.format(name))
                                for line in vim.current.buffer:
                                  if matcher.search(line) is not None:
                                    found = True
                                    break
                                  lnum += 1
                            
                                if not found:
                                  lnum = -1
                                return lnum
                            
                              def header(self):
                                curbuf = vim.current.buffer
                                curbuf[0] = self.event + ' plugins ({0}/{1})'.format(len(self.bar), self.num_plugs)
                            
                                num_spaces = self.num_plugs - len(self.bar)
                                curbuf[1] = '[{0}{1}]'.format(self.bar, num_spaces * ' ')
                            
                                with self.lock:
                                  vim.command('normal! 2G')
                                  vim.command('redraw')
                            
                              def write(self, action, name, lines):
                                first, rest = lines[0], lines[1:]
                                msg = ['{0} {1}{2}{3}'.format(action, name, ': ' if first else '', first)]
                                msg.extend(['    ' + line for line in rest])
                            
                                try:
                                  if action == Action.ERROR:
                                    self.bar += 'x'
                                    vim.command("call add(s:update.errors, '{0}')".format(name))
                                  elif action == Action.DONE:
                                    self.bar += '='
                            
                                  curbuf = vim.current.buffer
                                  lnum = self.__where(name)
                                  if lnum != -1: # Found matching line num
                                    del curbuf[lnum]
                                    if lnum > self.maxy and action in set([Action.INSTALL, Action.UPDATE]):
                                      lnum = 3
                                  else:
                                    lnum = 3
                                  curbuf.append(msg, lnum)
                            
                                  self.header()
                                except vim.error:
                                  pass
                            
                            class Command(object):
                              CD = 'cd /d' if G_IS_WIN else 'cd'
                            
                              def __init__(self, cmd, cmd_dir=None, timeout=60, cb=None, clean=None):
                                self.cmd = cmd
                                if cmd_dir:
                                  self.cmd = '{0} {1} && {2}'.format(Command.CD, cmd_dir, self.cmd)
                                self.timeout = timeout
                                self.callback = cb if cb else (lambda msg: None)
                                self.clean = clean if clean else (lambda: None)
                                self.proc = None
                            
                              @property
                              def alive(self):
                                """ Returns true only if command still running. """
                                return self.proc and self.proc.poll() is None
                            
                              def execute(self, ntries=3):
                                """ Execute the command with ntries if CmdTimedOut.
                                    Returns the output of the command if no Exception.
                                """
                                attempt, finished, limit = 0, False, self.timeout
                            
                                while not finished:
                                  try:
                                    attempt += 1
                                    result = self.try_command()
                                    finished = True
                                    return result
                                  except CmdTimedOut:
                                    if attempt != ntries:
                                      self.notify_retry()
                                      self.timeout += limit
                                    else:
                                      raise
                            
                              def notify_retry(self):
                                """ Retry required for command, notify user. """
                                for count in range(3, 0, -1):
                                  if G_STOP.is_set():
                                    raise KeyboardInterrupt
                                  msg = 'Timeout. Will retry in {0} second{1} ...'.format(
                                        count, 's' if count != 1 else '')
                                  self.callback([msg])
                                  time.sleep(1)
                                self.callback(['Retrying ...'])
                            
                              def try_command(self):
                                """ Execute a cmd & poll for callback. Returns list of output.
                                    Raises CmdFailed   -> return code for Popen isn't 0
                                    Raises CmdTimedOut -> command exceeded timeout without new output
                                """
                                first_line = True
                            
                                try:
                                  tfile = tempfile.NamedTemporaryFile(mode='w+b')
                                  preexec_fn = not G_IS_WIN and os.setsid or None
                                  self.proc = subprocess.Popen(self.cmd, stdout=tfile,
                                                               stderr=subprocess.STDOUT,
                                                               stdin=subprocess.PIPE, shell=True,
                                                               preexec_fn=preexec_fn)
                                  thrd = thr.Thread(target=(lambda proc: proc.wait()), args=(self.proc,))
                                  thrd.start()
                            
                                  thread_not_started = True
                                  while thread_not_started:
                                    try:
                                      thrd.join(0.1)
                                      thread_not_started = False
                                    except RuntimeError:
                                      pass
                            
                                  while self.alive:
                                    if G_STOP.is_set():
                                      raise KeyboardInterrupt
                            
                                    if first_line or random.random() < G_LOG_PROB:
                                      first_line = False
                                      line = '' if G_IS_WIN else nonblock_read(tfile.name)
                                      if line:
                                        self.callback([line])
                            
                                    time_diff = time.time() - os.path.getmtime(tfile.name)
                                    if time_diff > self.timeout:
                                      raise CmdTimedOut(['Timeout!'])
                            
                                    thrd.join(0.5)
                            
                                  tfile.seek(0)
                                  result = [line.decode('utf-8', 'replace').rstrip() for line in tfile]
                            
                                  if self.proc.returncode != 0:
                                    raise CmdFailed([''] + result)
                            
                                  return result
                                except:
                                  self.terminate()
                                  raise
                            
                              def terminate(self):
                                """ Terminate process and cleanup. """
                                if self.alive:
                                  if G_IS_WIN:
                                    os.kill(self.proc.pid, signal.SIGINT)
                                  else:
                                    os.killpg(self.proc.pid, signal.SIGTERM)
                                self.clean()
                            
                            class Plugin(object):
                              def __init__(self, name, args, buf_q, lock):
                                self.name = name
                                self.args = args
                                self.buf_q = buf_q
                                self.lock = lock
                                self.tag = args.get('tag', 0)
                            
                              def manage(self):
                                try:
                                  if os.path.exists(self.args['dir']):
                                    self.update()
                                  else:
                                    self.install()
                                    with self.lock:
                                      thread_vim_command("let s:update.new['{0}'] = 1".format(self.name))
                                except PlugError as exc:
                                  self.write(Action.ERROR, self.name, exc.msg)
                                except KeyboardInterrupt:
                                  G_STOP.set()
                                  self.write(Action.ERROR, self.name, ['Interrupted!'])
                                except:
                                  # Any exception except those above print stack trace
                                  msg = 'Trace:\n{0}'.format(traceback.format_exc().rstrip())
                                  self.write(Action.ERROR, self.name, msg.split('\n'))
                                  raise
                            
                              def install(self):
                                target = self.args['dir']
                                if target[-1] == '\\':
                                  target = target[0:-1]
                            
                                def clean(target):
                                  def _clean():
                                    try:
                                      shutil.rmtree(target)
                                    except OSError:
                                      pass
                                  return _clean
                            
                                self.write(Action.INSTALL, self.name, ['Installing ...'])
                                callback = functools.partial(self.write, Action.INSTALL, self.name)
                                cmd = 'git clone {0} {1} {2} {3} 2>&1'.format(
                                      '' if self.tag else G_CLONE_OPT, G_PROGRESS, self.args['uri'],
                                      esc(target))
                                com = Command(cmd, None, G_TIMEOUT, callback, clean(target))
                                result = com.execute(G_RETRIES)
                                self.write(Action.DONE, self.name, result[-1:])
                            
                              def repo_uri(self):
                                cmd = 'git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url'
                                command = Command(cmd, self.args['dir'], G_TIMEOUT,)
                                result = command.execute(G_RETRIES)
                                return result[-1]
                            
                              def update(self):
                                actual_uri = self.repo_uri()
                                expect_uri = self.args['uri']
                                regex = re.compile(r'^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$')
                                ma = regex.match(actual_uri)
                                mb = regex.match(expect_uri)
                                if ma is None or mb is None or ma.groups() != mb.groups():
                                  msg = ['',
                                         'Invalid URI: {0}'.format(actual_uri),
                                         'Expected     {0}'.format(expect_uri),
                                         'PlugClean required.']
                                  raise InvalidURI(msg)
                            
                                if G_PULL:
                                  self.write(Action.UPDATE, self.name, ['Updating ...'])
                                  callback = functools.partial(self.write, Action.UPDATE, self.name)
                                  fetch_opt = '--depth 99999999' if self.tag and os.path.isfile(os.path.join(self.args['dir'], '.git/shallow')) else ''
                                  cmd = 'git fetch {0} {1} 2>&1'.format(fetch_opt, G_PROGRESS)
                                  com = Command(cmd, self.args['dir'], G_TIMEOUT, callback)
                                  result = com.execute(G_RETRIES)
                                  self.write(Action.DONE, self.name, result[-1:])
                                else:
                                  self.write(Action.DONE, self.name, ['Already installed'])
                            
                              def write(self, action, name, msg):
                                self.buf_q.put((action, name, msg))
                            
                            class PlugThread(thr.Thread):
                              def __init__(self, tname, args):
                                super(PlugThread, self).__init__()
                                self.tname = tname
                                self.args = args
                            
                              def run(self):
                                thr.current_thread().name = self.tname
                                buf_q, work_q, lock = self.args
                            
                                try:
                                  while not G_STOP.is_set():
                                    name, args = work_q.get_nowait()
                                    plug = Plugin(name, args, buf_q, lock)
                                    plug.manage()
                                    work_q.task_done()
                                except queue.Empty:
                                  pass
                            
                            class RefreshThread(thr.Thread):
                              def __init__(self, lock):
                                super(RefreshThread, self).__init__()
                                self.lock = lock
                                self.running = True
                            
                              def run(self):
                                while self.running:
                                  with self.lock:
                                    thread_vim_command('noautocmd normal! a')
                                  time.sleep(0.33)
                            
                              def stop(self):
                                self.running = False
                            
                            if G_NVIM:
                              def thread_vim_command(cmd):
                                vim.session.threadsafe_call(lambda: vim.command(cmd))
                            else:
                              def thread_vim_command(cmd):
                                vim.command(cmd)
                            
                            def esc(name):
                              return '"' + name.replace('"', '\"') + '"'
                            
                            def nonblock_read(fname):
                              """ Read a file with nonblock flag. Return the last line. """
                              fread = os.open(fname, os.O_RDONLY | os.O_NONBLOCK)
                              buf = os.read(fread, 100000).decode('utf-8', 'replace')
                              os.close(fread)
                            
                              line = buf.rstrip('\r\n')
                              left = max(line.rfind('\r'), line.rfind('\n'))
                              if left != -1:
                                left += 1
                                line = line[left:]
                            
                              return line
                            
                            def main():
                              thr.current_thread().name = 'main'
                              nthreads = int(vim.eval('s:update.threads'))
                              plugs = vim.eval('s:update.todo')
                              mac_gui = vim.eval('s:mac_gui') == '1'
                            
                              lock = thr.Lock()
                              buf = Buffer(lock, len(plugs), G_PULL)
                              buf_q, work_q = queue.Queue(), queue.Queue()
                              for work in plugs.items():
                                work_q.put(work)
                            
                              start_cnt = thr.active_count()
                              for num in range(nthreads):
                                tname = 'PlugT-{0:02}'.format(num)
                                thread = PlugThread(tname, (buf_q, work_q, lock))
                                thread.start()
                              if mac_gui:
                                rthread = RefreshThread(lock)
                                rthread.start()
                            
                              while not buf_q.empty() or thr.active_count() != start_cnt:
                                try:
                                  action, name, msg = buf_q.get(True, 0.25)
                                  buf.write(action, name, ['OK'] if not msg else msg)
                                  buf_q.task_done()
                                except queue.Empty:
                                  pass
                                except KeyboardInterrupt:
                                  G_STOP.set()
                            
                              if mac_gui:
                                rthread.stop()
                                rthread.join()
                            
                            main()
                            EOF
                            endfunction
                            
    1              0.000001 function! s:update_ruby()
                              ruby << EOF
                              module PlugStream
                                SEP = ["\r", "\n", nil]
                                def get_line
                                  buffer = ''
                                  loop do
                                    char = readchar rescue return
                                    if SEP.include? char.chr
                                      buffer << $/
                                      break
                                    else
                                      buffer << char
                                    end
                                  end
                                  buffer
                                end
                              end unless defined?(PlugStream)
                            
                              def esc arg
                                %["#{arg.gsub('"', '\"')}"]
                              end
                            
                              def killall pid
                                pids = [pid]
                                if /mswin|mingw|bccwin/ =~ RUBY_PLATFORM
                                  pids.each { |pid| Process.kill 'INT', pid.to_i rescue nil }
                                else
                                  unless `which pgrep 2> /dev/null`.empty?
                                    children = pids
                                    until children.empty?
                                      children = children.map { |pid|
                                        `pgrep -P #{pid}`.lines.map { |l| l.chomp }
                                      }.flatten
                                      pids += children
                                    end
                                  end
                                  pids.each { |pid| Process.kill 'TERM', pid.to_i rescue nil }
                                end
                              end
                            
                              def compare_git_uri a, b
                                regex = %r{^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$}
                                regex.match(a).to_a.drop(1) == regex.match(b).to_a.drop(1)
                              end
                            
                              require 'thread'
                              require 'fileutils'
                              require 'timeout'
                              running = true
                              iswin = VIM::evaluate('s:is_win').to_i == 1
                              pull  = VIM::evaluate('s:update.pull').to_i == 1
                              base  = VIM::evaluate('g:plug_home')
                              all   = VIM::evaluate('s:update.todo')
                              limit = VIM::evaluate('get(g:, "plug_timeout", 60)')
                              tries = VIM::evaluate('get(g:, "plug_retries", 2)') + 1
                              nthr  = VIM::evaluate('s:update.threads').to_i
                              maxy  = VIM::evaluate('winheight(".")').to_i
                              vim7  = VIM::evaluate('v:version').to_i <= 703 && RUBY_PLATFORM =~ /darwin/
                              cd    = iswin ? 'cd /d' : 'cd'
                              tot   = VIM::evaluate('len(s:update.todo)') || 0
                              bar   = ''
                              skip  = 'Already installed'
                              mtx   = Mutex.new
                              take1 = proc { mtx.synchronize { running && all.shift } }
                              logh  = proc {
                                cnt = bar.length
                                $curbuf[1] = "#{pull ? 'Updating' : 'Installing'} plugins (#{cnt}/#{tot})"
                                $curbuf[2] = '[' + bar.ljust(tot) + ']'
                                VIM::command('normal! 2G')
                                VIM::command('redraw')
                              }
                              where = proc { |name| (1..($curbuf.length)).find { |l| $curbuf[l] =~ /^[-+x*] #{name}:/ } }
                              log   = proc { |name, result, type|
                                mtx.synchronize do
                                  ing  = ![true, false].include?(type)
                                  bar += type ? '=' : 'x' unless ing
                                  b = case type
                                      when :install  then '+' when :update then '*'
                                      when true, nil then '-' else
                                        VIM::command("call add(s:update.errors, '#{name}')")
                                        'x'
                                      end
                                  result =
                                    if type || type.nil?
                                      ["#{b} #{name}: #{result.lines.to_a.last || 'OK'}"]
                                    elsif result =~ /^Interrupted|^Timeout/
                                      ["#{b} #{name}: #{result}"]
                                    else
                                      ["#{b} #{name}"] + result.lines.map { |l| "    " << l }
                                    end
                                  if lnum = where.call(name)
                                    $curbuf.delete lnum
                                    lnum = 4 if ing && lnum > maxy
                                  end
                                  result.each_with_index do |line, offset|
                                    $curbuf.append((lnum || 4) - 1 + offset, line.gsub(/\e\[./, '').chomp)
                                  end
                                  logh.call
                                end
                              }
                              bt = proc { |cmd, name, type, cleanup|
                                tried = timeout = 0
                                begin
                                  tried += 1
                                  timeout += limit
                                  fd = nil
                                  data = ''
                                  if iswin
                                    Timeout::timeout(timeout) do
                                      tmp = VIM::evaluate('tempname()')
                                      system("(#{cmd}) > #{tmp}")
                                      data = File.read(tmp).chomp
                                      File.unlink tmp rescue nil
                                    end
                                  else
                                    fd = IO.popen(cmd).extend(PlugStream)
                                    first_line = true
                                    log_prob = 1.0 / nthr
                                    while line = Timeout::timeout(timeout) { fd.get_line }
                                      data << line
                                      log.call name, line.chomp, type if name && (first_line || rand < log_prob)
                                      first_line = false
                                    end
                                    fd.close
                                  end
                                  [$? == 0, data.chomp]
                                rescue Timeout::Error, Interrupt => e
                                  if fd && !fd.closed?
                                    killall fd.pid
                                    fd.close
                                  end
                                  cleanup.call if cleanup
                                  if e.is_a?(Timeout::Error) && tried < tries
                                    3.downto(1) do |countdown|
                                      s = countdown > 1 ? 's' : ''
                                      log.call name, "Timeout. Will retry in #{countdown} second#{s} ...", type
                                      sleep 1
                                    end
                                    log.call name, 'Retrying ...', type
                                    retry
                                  end
                                  [false, e.is_a?(Interrupt) ? "Interrupted!" : "Timeout!"]
                                end
                              }
                              main = Thread.current
                              threads = []
                              watcher = Thread.new {
                                if vim7
                                  while VIM::evaluate('getchar(1)')
                                    sleep 0.1
                                  end
                                else
                                  require 'io/console' # >= Ruby 1.9
                                  nil until IO.console.getch == 3.chr
                                end
                                mtx.synchronize do
                                  running = false
                                  threads.each { |t| t.raise Interrupt } unless vim7
                                end
                                threads.each { |t| t.join rescue nil }
                                main.kill
                              }
                              refresh = Thread.new {
                                while true
                                  mtx.synchronize do
                                    break unless running
                                    VIM::command('noautocmd normal! a')
                                  end
                                  sleep 0.2
                                end
                              } if VIM::evaluate('s:mac_gui') == 1
                            
                              clone_opt = VIM::evaluate('s:clone_opt').join(' ')
                              progress = VIM::evaluate('s:progress_opt(1)')
                              nthr.times do
                                mtx.synchronize do
                                  threads << Thread.new {
                                    while pair = take1.call
                                      name = pair.first
                                      dir, uri, tag = pair.last.values_at *%w[dir uri tag]
                                      exists = File.directory? dir
                                      ok, result =
                                        if exists
                                          chdir = "#{cd} #{iswin ? dir : esc(dir)}"
                                          ret, data = bt.call "#{chdir} && git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url", nil, nil, nil
                                          current_uri = data.lines.to_a.last
                                          if !ret
                                            if data =~ /^Interrupted|^Timeout/
                                              [false, data]
                                            else
                                              [false, [data.chomp, "PlugClean required."].join($/)]
                                            end
                                          elsif !compare_git_uri(current_uri, uri)
                                            [false, ["Invalid URI: #{current_uri}",
                                                     "Expected:    #{uri}",
                                                     "PlugClean required."].join($/)]
                                          else
                                            if pull
                                              log.call name, 'Updating ...', :update
                                              fetch_opt = (tag && File.exist?(File.join(dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                              bt.call "#{chdir} && git fetch #{fetch_opt} #{progress} 2>&1", name, :update, nil
                                            else
                                              [true, skip]
                                            end
                                          end
                                        else
                                          d = esc dir.sub(%r{[\\/]+$}, '')
                                          log.call name, 'Installing ...', :install
                                          bt.call "git clone #{clone_opt unless tag} #{progress} #{uri} #{d} 2>&1", name, :install, proc {
                                            FileUtils.rm_rf dir
                                          }
                                        end
                                      mtx.synchronize { VIM::command("let s:update.new['#{name}'] = 1") } if !exists && ok
                                      log.call name, result, ok
                                    end
                                  } if running
                                end
                              end
                              threads.each { |t| t.join rescue nil }
                              logh.call
                              refresh.kill if refresh
                              watcher.kill
                            EOF
                            endfunction
                            
    1              0.000001 function! s:shellesc_cmd(arg, script)
                              let escaped = substitute('"'.a:arg.'"', '[&|<>()@^!"]', '^&', 'g')
                              return substitute(escaped, '%', (a:script ? '%' : '^') . '&', 'g')
                            endfunction
                            
    1              0.000001 function! s:shellesc_ps1(arg)
                              return "'".substitute(escape(a:arg, '\"'), "'", "''", 'g')."'"
                            endfunction
                            
    1              0.000001 function! s:shellesc_sh(arg)
                              return "'".substitute(a:arg, "'", "'\\\\''", 'g')."'"
                            endfunction
                            
                            " Escape the shell argument based on the shell.
                            " Vim and Neovim's shellescape() are insufficient.
                            " 1. shellslash determines whether to use single/double quotes.
                            "    Double-quote escaping is fragile for cmd.exe.
                            " 2. It does not work for powershell.
                            " 3. It does not work for *sh shells if the command is executed
                            "    via cmd.exe (ie. cmd.exe /c sh -c command command_args)
                            " 4. It does not support batchfile syntax.
                            "
                            " Accepts an optional dictionary with the following keys:
                            " - shell: same as Vim/Neovim 'shell' option.
                            "          If unset, fallback to 'cmd.exe' on Windows or 'sh'.
                            " - script: If truthy and shell is cmd.exe, escape for batchfile syntax.
    1              0.000001 function! plug#shellescape(arg, ...)
                              if a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              endif
                              let opts = a:0 > 0 && type(a:1) == s:TYPE.dict ? a:1 : {}
                              let shell = get(opts, 'shell', s:is_win ? 'cmd.exe' : 'sh')
                              let script = get(opts, 'script', 1)
                              if shell =~# 'cmd\(\.exe\)\?$'
                                return s:shellesc_cmd(a:arg, script)
                              elseif s:is_powershell(shell)
                                return s:shellesc_ps1(a:arg)
                              endif
                              return s:shellesc_sh(a:arg)
                            endfunction
                            
    1              0.000001 function! s:glob_dir(path)
                              return map(filter(s:glob(a:path, '**'), 'isdirectory(v:val)'), 's:dirpath(v:val)')
                            endfunction
                            
    1              0.000001 function! s:progress_bar(line, bar, total)
                              call setline(a:line, '[' . s:lpad(a:bar, a:total) . ']')
                            endfunction
                            
    1              0.000001 function! s:compare_git_uri(a, b)
                              " See `git help clone'
                              " https:// [user@] github.com[:port] / junegunn/vim-plug [.git]
                              "          [git@]  github.com[:port] : junegunn/vim-plug [.git]
                              " file://                            / junegunn/vim-plug        [/]
                              "                                    / junegunn/vim-plug        [/]
                              let pat = '^\%(\w\+://\)\='.'\%([^@/]*@\)\='.'\([^:/]*\%(:[0-9]*\)\=\)'.'[:/]'.'\(.\{-}\)'.'\%(\.git\)\=/\?$'
                              let ma = matchlist(a:a, pat)
                              let mb = matchlist(a:b, pat)
                              return ma[1:2] ==# mb[1:2]
                            endfunction
                            
    1              0.000001 function! s:format_message(bullet, name, message)
                              if a:bullet != 'x'
                                return [printf('%s %s: %s', a:bullet, a:name, s:lastline(a:message))]
                              else
                                let lines = map(s:lines(a:message), '"    ".v:val')
                                return extend([printf('x %s:', a:name)], lines)
                              endif
                            endfunction
                            
    1              0.000001 function! s:with_cd(cmd, dir, ...)
                              let script = a:0 > 0 ? a:1 : 1
                              let pwsh = s:is_powershell(&shell)
                              let cd = s:is_win && !pwsh ? 'cd /d' : 'cd'
                              let sep = pwsh ? ';' : '&&'
                              return printf('%s %s %s %s', cd, plug#shellescape(a:dir, {'script': script, 'shell': &shell}), sep, a:cmd)
                            endfunction
                            
    1              0.000001 function! s:system(cmd, ...)
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                if type(a:cmd) == s:TYPE.list
                                  " Neovim's system() supports list argument to bypass the shell
                                  " but it cannot set the working directory for the command.
                                  " Assume that the command does not rely on the shell.
                                  if has('nvim') && a:0 == 0
                                    return system(a:cmd)
                                  endif
                                  let cmd = join(map(copy(a:cmd), 'plug#shellescape(v:val, {"shell": &shell, "script": 0})'))
                                  if s:is_powershell(&shell)
                                    let cmd = '& ' . cmd
                                  endif
                                else
                                  let cmd = a:cmd
                                endif
                                if a:0 > 0
                                  let cmd = s:with_cd(cmd, a:1, type(a:cmd) != s:TYPE.list)
                                endif
                                if s:is_win && type(a:cmd) != s:TYPE.list
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                return system(cmd)
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:system_chomp(...)
                              let ret = call('s:system', a:000)
                              return v:shell_error ? '' : substitute(ret, '\n$', '', '')
                            endfunction
                            
    1              0.000001 function! s:git_validate(spec, check_branch)
                              let err = ''
                              if isdirectory(a:spec.dir)
                                let result = [s:git_local_branch(a:spec.dir), s:git_origin_url(a:spec.dir)]
                                let remote = result[-1]
                                if empty(remote)
                                  let err = join([remote, 'PlugClean required.'], "\n")
                                elseif !s:compare_git_uri(remote, a:spec.uri)
                                  let err = join(['Invalid URI: '.remote,
                                                \ 'Expected:    '.a:spec.uri,
                                                \ 'PlugClean required.'], "\n")
                                elseif a:check_branch && has_key(a:spec, 'commit')
                                  let sha = s:git_revision(a:spec.dir)
                                  if empty(sha)
                                    let err = join(add(result, 'PlugClean required.'), "\n")
                                  elseif !s:hash_match(sha, a:spec.commit)
                                    let err = join([printf('Invalid HEAD (expected: %s, actual: %s)',
                                                          \ a:spec.commit[:6], sha[:6]),
                                                  \ 'PlugUpdate required.'], "\n")
                                  endif
                                elseif a:check_branch
                                  let current_branch = result[0]
                                  " Check tag
                                  let origin_branch = s:git_origin_branch(a:spec)
                                  if has_key(a:spec, 'tag')
                                    let tag = s:system_chomp('git describe --exact-match --tags HEAD 2>&1', a:spec.dir)
                                    if a:spec.tag !=# tag && a:spec.tag !~ '\*'
                                      let err = printf('Invalid tag: %s (expected: %s). Try PlugUpdate.',
                                            \ (empty(tag) ? 'N/A' : tag), a:spec.tag)
                                    endif
                                  " Check branch
                                  elseif origin_branch !=# current_branch
                                    let err = printf('Invalid branch: %s (expected: %s). Try PlugUpdate.',
                                          \ current_branch, origin_branch)
                                  endif
                                  if empty(err)
                                    let ahead_behind = split(s:lastline(s:system([
                                      \ 'git', 'rev-list', '--count', '--left-right',
                                      \ printf('HEAD...origin/%s', origin_branch)
                                      \ ], a:spec.dir)), '\t')
                                    if v:shell_error || len(ahead_behind) != 2
                                      let err = "Failed to compare with the origin. The default branch might have changed.\nPlugClean required."
                                    else
                                      let [ahead, behind] = ahead_behind
                                      if ahead && behind
                                        " Only mention PlugClean if diverged, otherwise it's likely to be
                                        " pushable (and probably not that messed up).
                                        let err = printf(
                                              \ "Diverged from origin/%s (%d commit(s) ahead and %d commit(s) behind!\n"
                                              \ .'Backup local changes and run PlugClean and PlugUpdate to reinstall it.', origin_branch, ahead, behind)
                                      elseif ahead
                                        let err = printf("Ahead of origin/%s by %d commit(s).\n"
                                              \ .'Cannot update until local changes are pushed.',
                                              \ origin_branch, ahead)
                                      endif
                                    endif
                                  endif
                                endif
                              else
                                let err = 'Not found'
                              endif
                              return [err, err =~# 'PlugClean']
                            endfunction
                            
    1              0.000001 function! s:rm_rf(dir)
                              if isdirectory(a:dir)
                                return s:system(s:is_win
                                \ ? 'rmdir /S /Q '.plug#shellescape(a:dir)
                                \ : ['rm', '-rf', a:dir])
                              endif
                            endfunction
                            
    1              0.000001 function! s:clean(force)
                              call s:prepare()
                              call append(0, 'Searching for invalid plugins in '.g:plug_home)
                              call append(1, '')
                            
                              " List of valid directories
                              let dirs = []
                              let errs = {}
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                if !s:is_managed(name) || get(spec, 'frozen', 0)
                                  call add(dirs, spec.dir)
                                else
                                  let [err, clean] = s:git_validate(spec, 1)
                                  if clean
                                    let errs[spec.dir] = s:lines(err)[0]
                                  else
                                    call add(dirs, spec.dir)
                                  endif
                                endif
                                let cnt += 1
                                call s:progress_bar(2, repeat('=', cnt), total)
                                normal! 2G
                                redraw
                              endfor
                            
                              let allowed = {}
                              for dir in dirs
                                let allowed[s:dirpath(s:plug_fnamemodify(dir, ':h:h'))] = 1
                                let allowed[dir] = 1
                                for child in s:glob_dir(dir)
                                  let allowed[child] = 1
                                endfor
                              endfor
                            
                              let todo = []
                              let found = sort(s:glob_dir(g:plug_home))
                              while !empty(found)
                                let f = remove(found, 0)
                                if !has_key(allowed, f) && isdirectory(f)
                                  call add(todo, f)
                                  call append(line('$'), '- ' . f)
                                  if has_key(errs, f)
                                    call append(line('$'), '    ' . errs[f])
                                  endif
                                  let found = filter(found, 'stridx(v:val, f) != 0')
                                end
                              endwhile
                            
                              4
                              redraw
                              if empty(todo)
                                call append(line('$'), 'Already clean.')
                              else
                                let s:clean_count = 0
                                call append(3, ['Directories to delete:', ''])
                                redraw!
                                if a:force || s:ask_no_interrupt('Delete all directories?')
                                  call s:delete([6, line('$')], 1)
                                else
                                  call setline(4, 'Cancelled.')
                                  nnoremap <silent> <buffer> d :set opfunc=<sid>delete_op<cr>g@
                                  nmap     <silent> <buffer> dd d_
                                  xnoremap <silent> <buffer> d :<c-u>call <sid>delete_op(visualmode(), 1)<cr>
                                  echo 'Delete the lines (d{motion}) to delete the corresponding directories'
                                endif
                              endif
                              4
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:delete_op(type, ...)
                              call s:delete(a:0 ? [line("'<"), line("'>")] : [line("'["), line("']")], 0)
                            endfunction
                            
    1              0.000001 function! s:delete(range, force)
                              let [l1, l2] = a:range
                              let force = a:force
                              let err_count = 0
                              while l1 <= l2
                                let line = getline(l1)
                                if line =~ '^- ' && isdirectory(line[2:])
                                  execute l1
                                  redraw!
                                  let answer = force ? 1 : s:ask('Delete '.line[2:].'?', 1)
                                  let force = force || answer > 1
                                  if answer
                                    let err = s:rm_rf(line[2:])
                                    setlocal modifiable
                                    if empty(err)
                                      call setline(l1, '~'.line[1:])
                                      let s:clean_count += 1
                                    else
                                      delete _
                                      call append(l1 - 1, s:format_message('x', line[1:], err))
                                      let l2 += len(s:lines(err))
                                      let err_count += 1
                                    endif
                                    let msg = printf('Removed %d directories.', s:clean_count)
                                    if err_count > 0
                                      let msg .= printf(' Failed to remove %d directories.', err_count)
                                    endif
                                    call setline(4, msg)
                                    setlocal nomodifiable
                                  endif
                                endif
                                let l1 += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:upgrade()
                              echo 'Downloading the latest version of vim-plug'
                              redraw
                              let tmp = s:plug_tempname()
                              let new = tmp . '/plug.vim'
                            
                              try
                                let out = s:system(['git', 'clone', '--depth', '1', s:plug_src, tmp])
                                if v:shell_error
                                  return s:err('Error upgrading vim-plug: '. out)
                                endif
                            
                                if readfile(s:me) ==# readfile(new)
                                  echo 'vim-plug is already up-to-date'
                                  return 0
                                else
                                  call rename(s:me, s:me . '.old')
                                  call rename(new, s:me)
                                  unlet g:loaded_plug
                                  echo 'vim-plug has been upgraded'
                                  return 1
                                endif
                              finally
                                silent! call s:rm_rf(tmp)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:upgrade_specs()
                              for spec in values(g:plugs)
                                let spec.frozen = get(spec, 'frozen', 0)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:status()
                              call s:prepare()
                              call append(0, 'Checking plugins')
                              call append(1, '')
                            
                              let ecnt = 0
                              let unloaded = 0
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                let is_dir = isdirectory(spec.dir)
                                if has_key(spec, 'uri')
                                  if is_dir
                                    let [err, _] = s:git_validate(spec, 1)
                                    let [valid, msg] = [empty(err), empty(err) ? 'OK' : err]
                                  else
                                    let [valid, msg] = [0, 'Not found. Try PlugInstall.']
                                  endif
                                else
                                  if is_dir
                                    let [valid, msg] = [1, 'OK']
                                  else
                                    let [valid, msg] = [0, 'Not found.']
                                  endif
                                endif
                                let cnt += 1
                                let ecnt += !valid
                                " `s:loaded` entry can be missing if PlugUpgraded
                                if is_dir && get(s:loaded, name, -1) == 0
                                  let unloaded = 1
                                  let msg .= ' (not loaded)'
                                endif
                                call s:progress_bar(2, repeat('=', cnt), total)
                                call append(3, s:format_message(valid ? '-' : 'x', name, msg))
                                normal! 2G
                                redraw
                              endfor
                              call setline(1, 'Finished. '.ecnt.' error(s).')
                              normal! gg
                              setlocal nomodifiable
                              if unloaded
                                echo "Press 'L' on each line to load plugin, or 'U' to update"
                                nnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                                xnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                              end
                            endfunction
                            
    1              0.000001 function! s:extract_name(str, prefix, suffix)
                              return matchstr(a:str, '^'.a:prefix.' \zs[^:]\+\ze:.*'.a:suffix.'$')
                            endfunction
                            
    1              0.000001 function! s:status_load(lnum)
                              let line = getline(a:lnum)
                              let name = s:extract_name(line, '-', '(not loaded)')
                              if !empty(name)
                                call plug#load(name)
                                setlocal modifiable
                                call setline(a:lnum, substitute(line, ' (not loaded)$', '', ''))
                                setlocal nomodifiable
                              endif
                            endfunction
                            
    1              0.000001 function! s:status_update() range
                              let lines = getline(a:firstline, a:lastline)
                              let names = filter(map(lines, 's:extract_name(v:val, "[x-]", "")'), '!empty(v:val)')
                              if !empty(names)
                                echo
                                execute 'PlugUpdate' join(names)
                              endif
                            endfunction
                            
    1              0.000001 function! s:is_preview_window_open()
                              silent! wincmd P
                              if &previewwindow
                                wincmd p
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:find_name(lnum)
                              for lnum in reverse(range(1, a:lnum))
                                let line = getline(lnum)
                                if empty(line)
                                  return ''
                                endif
                                let name = s:extract_name(line, '-', '')
                                if !empty(name)
                                  return name
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:preview_commit()
                              if b:plug_preview < 0
                                let b:plug_preview = !s:is_preview_window_open()
                              endif
                            
                              let sha = matchstr(getline('.'), '^  \X*\zs[0-9a-f]\{7,9}')
                              if empty(sha)
                                let name = matchstr(getline('.'), '^- \zs[^:]*\ze:$')
                                if empty(name)
                                  return
                                endif
                                let title = 'HEAD@{1}..'
                                let command = 'git diff --no-color HEAD@{1}'
                              else
                                let title = sha
                                let command = 'git show --no-color --pretty=medium '.sha
                                let name = s:find_name(line('.'))
                              endif
                            
                              if empty(name) || !has_key(g:plugs, name) || !isdirectory(g:plugs[name].dir)
                                return
                              endif
                            
                              if !s:is_preview_window_open()
                                execute get(g:, 'plug_pwindow', 'vertical rightbelow new')
                                execute 'e' title
                              else
                                execute 'pedit' title
                                wincmd P
                              endif
                              setlocal previewwindow filetype=git buftype=nofile bufhidden=wipe nobuflisted modifiable
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                let cmd = 'cd '.plug#shellescape(g:plugs[name].dir).' && '.command
                                if s:is_win
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                execute 'silent %!' cmd
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                              setlocal nomodifiable
                              nnoremap <silent> <buffer> q :q<cr>
                              wincmd p
                            endfunction
                            
    1              0.000001 function! s:section(flags)
                              call search('\(^[x-] \)\@<=[^:]\+:', a:flags)
                            endfunction
                            
    1              0.000001 function! s:format_git_log(line)
                              let indent = '  '
                              let tokens = split(a:line, nr2char(1))
                              if len(tokens) != 5
                                return indent.substitute(a:line, '\s*$', '', '')
                              endif
                              let [graph, sha, refs, subject, date] = tokens
                              let tag = matchstr(refs, 'tag: [^,)]\+')
                              let tag = empty(tag) ? ' ' : ' ('.tag.') '
                              return printf('%s%s%s%s%s (%s)', indent, graph, sha, tag, subject, date)
                            endfunction
                            
    1              0.000001 function! s:append_ul(lnum, text)
                              call append(a:lnum, ['', a:text, repeat('-', len(a:text))])
                            endfunction
                            
    1              0.000001 function! s:diff()
                              call s:prepare()
                              call append(0, ['Collecting changes ...', ''])
                              let cnts = [0, 0]
                              let bar = ''
                              let total = filter(copy(g:plugs), 's:is_managed(v:key) && isdirectory(v:val.dir)')
                              call s:progress_bar(2, bar, len(total))
                              for origin in [1, 0]
                                let plugs = reverse(sort(items(filter(copy(total), (origin ? '' : '!').'(has_key(v:val, "commit") || has_key(v:val, "tag"))'))))
                                if empty(plugs)
                                  continue
                                endif
                                call s:append_ul(2, origin ? 'Pending updates:' : 'Last update:')
                                for [k, v] in plugs
                                  let branch = s:git_origin_branch(v)
                                  if len(branch)
                                    let range = origin ? '..origin/'.branch : 'HEAD@{1}..'
                                    let cmd = ['git', 'log', '--graph', '--color=never']
                                    if s:git_version_requirement(2, 10, 0)
                                      call add(cmd, '--no-show-signature')
                                    endif
                                    call extend(cmd, ['--pretty=format:%x01%h%x01%d%x01%s%x01%cr', range])
                                    if has_key(v, 'rtp')
                                      call extend(cmd, ['--', v.rtp])
                                    endif
                                    let diff = s:system_chomp(cmd, v.dir)
                                    if !empty(diff)
                                      let ref = has_key(v, 'tag') ? (' (tag: '.v.tag.')') : has_key(v, 'commit') ? (' '.v.commit) : ''
                                      call append(5, extend(['', '- '.k.':'.ref], map(s:lines(diff), 's:format_git_log(v:val)')))
                                      let cnts[origin] += 1
                                    endif
                                  endif
                                  let bar .= '='
                                  call s:progress_bar(2, bar, len(total))
                                  normal! 2G
                                  redraw
                                endfor
                                if !cnts[origin]
                                  call append(5, ['', 'N/A'])
                                endif
                              endfor
                              call setline(1, printf('%d plugin(s) updated.', cnts[0])
                                    \ . (cnts[1] ? printf(' %d plugin(s) have pending updates.', cnts[1]) : ''))
                            
                              if cnts[0] || cnts[1]
                                nnoremap <silent> <buffer> <plug>(plug-preview) :silent! call <SID>preview_commit()<cr>
                                if empty(maparg("\<cr>", 'n'))
                                  nmap <buffer> <cr> <plug>(plug-preview)
                                endif
                                if empty(maparg('o', 'n'))
                                  nmap <buffer> o <plug>(plug-preview)
                                endif
                              endif
                              if cnts[0]
                                nnoremap <silent> <buffer> X :call <SID>revert()<cr>
                                echo "Press 'X' on each block to revert the update"
                              endif
                              normal! gg
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:revert()
                              if search('^Pending updates', 'bnW')
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) ||
                                \ input(printf('Revert the update of %s? (y/N) ', name)) !~? '^y'
                                return
                              endif
                            
                              call s:system('git reset --hard HEAD@{1} && git checkout '.plug#shellescape(g:plugs[name].branch).' --', g:plugs[name].dir)
                              setlocal modifiable
                              normal! "_dap
                              setlocal nomodifiable
                              echo 'Reverted'
                            endfunction
                            
    1              0.000001 function! s:snapshot(force, ...) abort
                              call s:prepare()
                              setf vim
                              call append(0, ['" Generated by vim-plug',
                                            \ '" '.strftime("%c"),
                                            \ '" :source this file in vim to restore the snapshot',
                                            \ '" or execute: vim -S snapshot.vim',
                                            \ '', '', 'PlugUpdate!'])
                              1
                              let anchor = line('$') - 3
                              let names = sort(keys(filter(copy(g:plugs),
                                    \'has_key(v:val, "uri") && isdirectory(v:val.dir)')))
                              for name in reverse(names)
                                let sha = has_key(g:plugs[name], 'commit') ? g:plugs[name].commit : s:git_revision(g:plugs[name].dir)
                                if !empty(sha)
                                  call append(anchor, printf("silent! let g:plugs['%s'].commit = '%s'", name, sha))
                                  redraw
                                endif
                              endfor
                            
                              if a:0 > 0
                                let fn = s:plug_expand(a:1)
                                if filereadable(fn) && !(a:force || s:ask(a:1.' already exists. Overwrite?'))
                                  return
                                endif
                                call writefile(getline(1, '$'), fn)
                                echo 'Saved as '.a:1
                                silent execute 'e' s:esc(fn)
                                setf vim
                              endif
                            endfunction
                            
    1              0.000001 function! s:split_rtp()
                              return split(&rtp, '\\\@<!,')
                            endfunction
                            
    1   0.000056   0.000018 let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
    1   0.000037   0.000009 let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
                            
    1              0.000001 if exists('g:plugs')
                              let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
                              call s:upgrade_specs()
                              call s:define_commands()
    1              0.000001 endif
                            
    1              0.000003 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/filetype.lua
Sourced 1 time
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
                            if vim.g.did_load_filetypes then
                              return
                            end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                if not vim.api.nvim_buf_is_valid(args.buf) then
                                  return
                                end
                                local ft, on_detect = vim.filetype.match({
                                  -- The unexpanded file name is needed here. #27914
                                  -- Neither args.file nor args.match are guaranteed to be unexpanded.
                                  filename = vim.fn.bufname(args.buf),
                                  buf = args.buf,
                                })
                                if not ft then
                                  -- Generic configuration file used as fallback
                                  ft = require('vim.filetype.detect').conf(args.file, args.buf)
                                  if ft then
                                    vim.api.nvim_buf_call(args.buf, function()
                                      vim.api.nvim_cmd({ cmd = 'setf', args = { 'FALLBACK', ft } }, {})
                                    end)
                                  end
                                else
                                  -- on_detect is called before setting the filetype so that it can set any buffer local
                                  -- variables that may be used the filetype's ftplugin
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                            
                                  vim.api.nvim_buf_call(args.buf, function()
                                    vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})
                                  end)
                                end
                              end,
                            })
                            
                            -- These *must* be sourced after the autocommand above is created
                            if not vim.g.did_load_ftdetect then
                              vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.{vim,lua}
                              augroup END
                              ]])
                            end
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000349
 Self time:   0.000195

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000005 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000003 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000000 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000231   0.000149 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000005 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000001 augroup syntaxset
    1              0.000004   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000001 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000075   0.000004 doautoall syntaxset FileType
    1              0.000001 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000002 endif

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000005 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " let others know that syntax has been switched on
    1              0.000002 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000002 let s:cpo_save = &cpo
    1              0.000003 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000002 au! Syntax
                            
    1              0.000005 au Syntax *		call s:SynSet()
                            
    1              0.000003 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000010 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000002 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000000 endif
                            
                            " Restore 'cpoptions'
    1              0.000002 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /home/nagashima/.local/share/nvim/plugged/kanagawa.nvim/colors/kanagawa.vim
Sourced 1 time
Total time:   0.003292
 Self time:   0.003292

count  total (s)   self (s)
    1              0.003286 lua require('kanagawa').load()

SCRIPT  /home/nagashima/.local/share/nvim/plugged/nvim-lspconfig/plugin/lspconfig.lua
Sourced 1 time
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
                            if vim.g.lspconfig ~= nil then
                              return
                            end
                            vim.g.lspconfig = 1
                            
                            local api, lsp = vim.api, vim.lsp
                            
                            if vim.fn.has 'nvim-0.8' ~= 1 then
                              local version_info = vim.version()
                              local warning_str = string.format(
                                '[lspconfig] requires neovim 0.8 or later. Detected neovim version: 0.%s.%s',
                                version_info.minor,
                                version_info.patch
                              )
                              vim.notify_once(warning_str)
                              return
                            end
                            
                            local completion_sort = function(items)
                              table.sort(items)
                              return items
                            end
                            
                            local lsp_complete_configured_servers = function(arg)
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, require('lspconfig.util').available_servers()))
                            end
                            
                            local lsp_get_active_client_ids = function(arg)
                              local clients = vim.tbl_map(function(client)
                                return ('%d (%s)'):format(client.id, client.name)
                              end, require('lspconfig.util').get_managed_clients())
                            
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, clients))
                            end
                            
                            local get_clients_from_cmd_args = function(arg)
                              local result = {}
                              for id in (arg or ''):gmatch '(%d+)' do
                                result[#result + 1] = lsp.get_client_by_id(tonumber(id))
                              end
                              if #result == 0 then
                                return require('lspconfig.util').get_managed_clients()
                              end
                              return result
                            end
                            
                            for group, hi in pairs {
                              LspInfoBorder = { link = 'Label', default = true },
                              LspInfoList = { link = 'Function', default = true },
                              LspInfoTip = { link = 'Comment', default = true },
                              LspInfoTitle = { link = 'Title', default = true },
                              LspInfoFiletype = { link = 'Type', default = true },
                            } do
                              api.nvim_set_hl(0, group, hi)
                            end
                            
                            -- Called from plugin/lspconfig.vim because it requires knowing that the last
                            -- script in scriptnames to be executed is lspconfig.
                            api.nvim_create_user_command('LspInfo', function()
                              require 'lspconfig.ui.lspinfo'()
                            end, {
                              desc = 'Displays attached, active, and configured language servers',
                            })
                            
                            api.nvim_create_user_command('LspStart', function(info)
                              local server_name = string.len(info.args) > 0 and info.args or nil
                              if server_name then
                                local config = require('lspconfig.configs')[server_name]
                                if config then
                                  config.launch()
                                  return
                                end
                              end
                            
                              local matching_configs = require('lspconfig.util').get_config_by_ft(vim.bo.filetype)
                              for _, config in ipairs(matching_configs) do
                                config.launch()
                              end
                            end, {
                              desc = 'Manually launches a language server',
                              nargs = '?',
                              complete = lsp_complete_configured_servers,
                            })
                            
                            api.nvim_create_user_command('LspRestart', function(info)
                              local detach_clients = {}
                              for _, client in ipairs(get_clients_from_cmd_args(info.args)) do
                                client.stop()
                                if vim.tbl_count(client.attached_buffers) > 0 then
                                  detach_clients[client.name] = { client, lsp.get_buffers_by_client_id(client.id) }
                                end
                              end
                              local timer = vim.loop.new_timer()
                              timer:start(
                                500,
                                100,
                                vim.schedule_wrap(function()
                                  for client_name, tuple in pairs(detach_clients) do
                                    if require('lspconfig.configs')[client_name] then
                                      local client, attached_buffers = unpack(tuple)
                                      if client.is_stopped() then
                                        for _, buf in pairs(attached_buffers) do
                                          require('lspconfig.configs')[client_name].launch(buf)
                                        end
                                        detach_clients[client_name] = nil
                                      end
                                    end
                                  end
                            
                                  if next(detach_clients) == nil and not timer:is_closing() then
                                    timer:close()
                                  end
                                end)
                              )
                            end, {
                              desc = 'Manually restart the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspStop', function(info)
                              local current_buf = vim.api.nvim_get_current_buf()
                              local server_id, force
                              local arguments = vim.split(info.args, '%s')
                              for _, v in pairs(arguments) do
                                if v == '++force' then
                                  force = true
                                elseif v:find '^[0-9]+$' then
                                  server_id = v
                                end
                              end
                            
                              if not server_id then
                                local servers_on_buffer = require('lspconfig.util').get_lsp_clients { bufnr = current_buf }
                                for _, client in ipairs(servers_on_buffer) do
                                  if client.attached_buffers[current_buf] then
                                    client.stop(force)
                                  end
                                end
                              else
                                for _, client in ipairs(get_clients_from_cmd_args(server_id)) do
                                  client.stop(force)
                                end
                              end
                            end, {
                              desc = 'Manually stops the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspLog', function()
                              vim.cmd(string.format('tabnew %s', lsp.get_log_path()))
                            end, {
                              desc = 'Opens the Nvim LSP client log.',
                            })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/nvim-cmp/plugin/cmp.lua
Sourced 1 time
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
                            if vim.g.loaded_cmp then
                              return
                            end
                            vim.g.loaded_cmp = true
                            
                            if not vim.api.nvim_create_autocmd then
                              return print('[nvim-cmp] Your nvim does not has `nvim_create_autocmd` function. Please update to latest nvim.')
                            end
                            
                            local api = require('cmp.utils.api')
                            local types = require('cmp.types')
                            local highlight = require('cmp.utils.highlight')
                            local autocmd = require('cmp.utils.autocmd')
                            
                            vim.api.nvim_set_hl(0, 'CmpItemAbbr', { link = 'CmpItemAbbrDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrDeprecated', { link = 'CmpItemAbbrDeprecatedDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatch', { link = 'CmpItemAbbrMatchDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatchFuzzy', { link = 'CmpItemAbbrMatchFuzzyDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemKind', { link = 'CmpItemKindDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemMenu', { link = 'CmpItemMenuDefault', default = true })
                            for kind in pairs(types.lsp.CompletionItemKind) do
                              if type(kind) == 'string' then
                                local name = ('CmpItemKind%s'):format(kind)
                                vim.api.nvim_set_hl(0, name, { link = ('%sDefault'):format(name), default = true })
                              end
                            end
                            
                            autocmd.subscribe({ 'ColorScheme', 'UIEnter' }, function()
                              highlight.inherit('CmpItemAbbrDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrDeprecatedDefault', 'Comment', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchFuzzyDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemKindDefault', 'Special', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemMenuDefault', 'Pmenu', { bg = 'NONE', default = false })
                              for name in pairs(types.lsp.CompletionItemKind) do
                                if type(name) == 'string' then
                                  vim.api.nvim_set_hl(0, ('CmpItemKind%sDefault'):format(name), { link = 'CmpItemKind', default = false })
                                end
                              end
                            end)
                            autocmd.emit('ColorScheme')
                            
                            if vim.on_key then
                              local control_c_termcode = vim.api.nvim_replace_termcodes('<C-c>', true, true, true)
                              vim.on_key(function(keys)
                                if keys == control_c_termcode then
                                  vim.schedule(function()
                                    if not api.is_suitable_mode() then
                                      autocmd.emit('InsertLeave')
                                    end
                                  end)
                                end
                              end, vim.api.nvim_create_namespace('cmp.plugin'))
                            end
                            
                            
                            vim.api.nvim_create_user_command('CmpStatus', function()
                              require('cmp').status()
                            end, { desc = 'Check status of cmp sources' })
                            
                            vim.cmd([[doautocmd <nomodeline> User CmpReady]])

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/plugin/vsnip.vim
Sourced 1 time
Total time:   0.002708
 Self time:   0.000295

count  total (s)   self (s)
    1              0.000008 if exists('g:loaded_vsnip')
                              finish
    1              0.000001 endif
    1              0.000022 let g:loaded_vsnip = 1
                            
                            "
                            " variable
                            "
    1              0.000006 let g:vsnip_extra_mapping = get(g:, 'vsnip_extra_mapping', v:true)
    1   0.002460   0.000047 let g:vsnip_deactivate_on = get(g:, 'vsnip_deactivate_on', g:vsnip#DeactivateOn.OutsideOfCurrentTabstop)
    1              0.000007 let g:vsnip_snippet_dir = get(g:, 'vsnip_snippet_dir', expand('~/.vsnip'))
    1              0.000002 let g:vsnip_snippet_dirs = get(g:, 'vsnip_snippet_dirs', [])
    1              0.000002 let g:vsnip_sync_delay = get(g:, 'vsnip_sync_delay', 0)
    1              0.000002 let g:vsnip_choice_delay = get(g:, 'vsnip_choice_delay', 500)
    1              0.000002 let g:vsnip_append_final_tabstop = get(g:, 'vsnip_append_final_tabstop', v:true)
    1              0.000002 let g:vsnip_namespace = get(g:, 'vsnip_namespace', '')
    1              0.000002 let g:vsnip_filetypes = get(g:, 'vsnip_filetypes', {})
    1              0.000003 let g:vsnip_filetypes.typescriptreact = get(g:vsnip_filetypes, 'typescriptreact', ['typescript'])
    1              0.000002 let g:vsnip_filetypes.javascriptreact = get(g:vsnip_filetypes, 'javascriptreact', ['javascript'])
    1              0.000002 let g:vsnip_filetypes.vimspec = get(g:vsnip_filetypes, 'vimspec', ['vim'])
                            
    1              0.000003 augroup vsnip#silent
    1              0.000005   autocmd!
    1              0.000006   autocmd User vsnip#expand silent
    1              0.000002   autocmd User vsnip#jump silent
    1              0.000001 augroup END
                            
                            "
                            " command
                            "
    1              0.000006 command! -nargs=* -bang VsnipOpen call s:open_command(<bang>0, 'vsplit', <q-args>)
    1              0.000004 command! -nargs=* -bang VsnipOpenEdit call s:open_command(<bang>0, 'edit', <q-args>)
    1              0.000003 command! -nargs=* -bang VsnipOpenVsplit call s:open_command(<bang>0, 'vsplit', <q-args>)
    1              0.000003 command! -nargs=* -bang VsnipOpenSplit call s:open_command(<bang>0, 'split', <q-args>)
    1              0.000002 function! s:open_command(bang, cmd, arg)
                              let l:candidates = vsnip#source#filetypes(bufnr('%'))
                              if a:bang
                                let l:idx = 1
                              else
                                let l:idx = inputlist(['Select type: '] + map(copy(l:candidates), { k, v -> printf('%s: %s', k + 1, v) }))
                                if l:idx == 0
                                  return
                                endif
                              endif
                            
                              let l:expanded_dir = expand(g:vsnip_snippet_dir)
                              if !isdirectory(l:expanded_dir)
                                let l:prompt = printf('`%s` does not exists, create? y(es)/n(o): ', g:vsnip_snippet_dir)
                                if index(['y', 'ye', 'yes'], input(l:prompt)) >= 0
                                  call mkdir(l:expanded_dir, 'p')
                                else
                                  return
                                endif
                              endif
                            
                              let l:ext = a:arg =~# '-format\s\+snipmate' ? 'snippets' : 'json'
                            
                              execute printf('%s %s', a:cmd, fnameescape(printf('%s/%s.%s',
                              \   resolve(l:expanded_dir),
                              \   l:candidates[l:idx - 1],
                              \   l:ext
                              \ )))
                            endfunction
                            
    1              0.000004 command! -range -nargs=? -bar VsnipYank call s:add_command(<line1>, <line2>, <q-args>)
    1              0.000001 function! s:add_command(start, end, name) abort
                              let lines = map(getbufline('%', a:start, a:end), { key, val -> json_encode(substitute(val, '\$', '\\$', 'ge')) })
                              let format = "  \"%s\": {\n    \"prefix\": [\"%s\"],\n    \"body\": [\n      %s\n    ]\n  }"
                              let name = empty(a:name) ? 'new' : a:name
                            
                              let reg = &clipboard =~# 'unnamed' ? '*' : '"'
                              let reg = &clipboard =~# 'unnamedplus' ? '+' : reg
                              call setreg(reg, printf(format, name, name, join(lines, ",\n      ")), 'l')
                            endfunction
                            
                            "
                            " extra mapping
                            "
    1              0.000001 if g:vsnip_extra_mapping
    1              0.000006   snoremap <expr> <BS> ("\<BS>" . (&virtualedit ==# '' && getcurpos()[2] >= col('$') - 1 ? 'a' : 'i'))
    1              0.000001 endif
                            
                            "
                            " <Plug>(vsnip-expand-or-jump)
                            "
    1              0.000005 inoremap <silent> <Plug>(vsnip-expand-or-jump) <Esc>:<C-u>call <SID>expand_or_jump()<CR>
    1              0.000004 snoremap <silent> <Plug>(vsnip-expand-or-jump) <Esc>:<C-u>call <SID>expand_or_jump()<CR>
    1              0.000001 function! s:expand_or_jump()
                              let l:ctx = {}
                              function! l:ctx.callback() abort
                                let l:context = vsnip#get_context()
                                let l:session = vsnip#get_session()
                                if !empty(l:context)
                                  call vsnip#expand()
                                elseif !empty(l:session) && l:session.jumpable(1)
                                  call l:session.jump(1)
                                endif
                              endfunction
                            
                              " This is needed to keep normal-mode during 0ms to prevent CompleteDone handling by LSP Client.
                              let l:maybe_complete_done = !empty(v:completed_item) && has_key(v:completed_item, 'user_data') && !empty(v:completed_item.user_data)
                              if l:maybe_complete_done
                                call timer_start(0, { -> l:ctx.callback() })
                              else
                                call l:ctx.callback()
                              endif
                            endfunction
                            
                            "
                            " <Plug>(vsnip-expand)
                            "
    1              0.000003 inoremap <silent> <Plug>(vsnip-expand) <Esc>:<C-u>call <SID>expand()<CR>
    1              0.000005 snoremap <silent> <Plug>(vsnip-expand) <C-g><Esc>:<C-u>call <SID>expand()<CR>
    1              0.000001 function! s:expand() abort
                              let l:ctx = {}
                              function! l:ctx.callback() abort
                                call vsnip#expand()
                              endfunction
                            
                              " This is needed to keep normal-mode during 0ms to prevent CompleteDone handling by LSP Client.
                              let l:maybe_complete_done = !empty(v:completed_item) && has_key(v:completed_item, 'user_data') && !empty(v:completed_item.user_data)
                              if l:maybe_complete_done
                                call timer_start(0, { -> l:ctx.callback() })
                              else
                                call l:ctx.callback()
                              endif
                            endfunction
                            
                            "
                            " <Plug>(vsnip-jump-next)
                            " <Plug>(vsnip-jump-prev)
                            "
    1              0.000003 inoremap <silent> <Plug>(vsnip-jump-next) <Esc>:<C-u>call <SID>jump(1)<CR>
    1              0.000003 snoremap <silent> <Plug>(vsnip-jump-next) <Esc>:<C-u>call <SID>jump(1)<CR>
    1              0.000003 inoremap <silent> <Plug>(vsnip-jump-prev) <Esc>:<C-u>call <SID>jump(-1)<CR>
    1              0.000003 snoremap <silent> <Plug>(vsnip-jump-prev) <Esc>:<C-u>call <SID>jump(-1)<CR>
    1              0.000001 function! s:jump(direction) abort
                              let l:session = vsnip#get_session()
                              if !empty(l:session) && l:session.jumpable(a:direction)
                                call l:session.jump(a:direction)
                              endif
                            endfunction
                            
                            "
                            " <Plug>(vsnip-select-text)
                            "
    1              0.000005 nnoremap <silent> <Plug>(vsnip-select-text) :set operatorfunc=<SID>vsnip_select_text_normal<CR>g@
    1              0.000004 snoremap <silent> <Plug>(vsnip-select-text) <C-g>:<C-u>call <SID>vsnip_visual_text(visualmode())<CR>gv<C-g>
    1              0.000004 xnoremap <silent> <Plug>(vsnip-select-text) :<C-u>call <SID>vsnip_visual_text(visualmode())<CR>gv
    1              0.000001 function! s:vsnip_select_text_normal(type) abort
                              call s:vsnip_set_text(a:type)
                            endfunction
                            
                            "
                            " <Plug>(vsnip-cut-text)
                            "
    1              0.000004 nnoremap <silent> <Plug>(vsnip-cut-text) :set operatorfunc=<SID>vsnip_cut_text_normal<CR>g@
    1              0.000004 snoremap <silent> <Plug>(vsnip-cut-text) <C-g>:<C-u>call <SID>vsnip_visual_text(visualmode())<CR>gv"_c
    1              0.000003 xnoremap <silent> <Plug>(vsnip-cut-text) :<C-u>call <SID>vsnip_visual_text(visualmode())<CR>gv"_c
                            
    1              0.000001 function! s:vsnip_cut_text_normal(type) abort
                              call feedkeys(s:vsnip_set_text(a:type) . '"_c', 'n')
                            endfunction
    1              0.000001 function! s:vsnip_visual_text(type) abort
                              call s:vsnip_set_text(a:type)
                            endfunction
    1              0.000001 function! s:vsnip_set_text(type) abort
                              let oldreg = [getreg('"'), getregtype('"')]
                              if a:type ==# 'v'
                                let select = '`<v`>'
                              elseif a:type ==# 'V'
                                let select = "'<V'>"
                              elseif a:type ==? "\<C-V>"
                                let select = "`<\<C-V>`>"
                              elseif a:type ==# 'char'
                                let select = '`[v`]'
                              elseif a:type ==# 'line'
                                let select = "'[V']"
                              else
                                return
                              endif
                              execute 'normal! ' . select . 'y'
                              call vsnip#selected_text(@")
                              call setreg('"', oldreg[0], oldreg[1])
                              return select
                            endfunction
                            
                            "
                            " augroup.
                            "
    1              0.000001 augroup vsnip
    1              0.000002   autocmd!
    1              0.000004   autocmd InsertLeave * call s:on_insert_leave()
    1              0.000006   autocmd TextChanged,TextChangedI,TextChangedP * call s:on_text_changed()
    1              0.000002   autocmd BufWritePost * call s:on_buf_write_post()
    1              0.000005   autocmd BufRead,BufNewFile *.snippets setlocal filetype=snippets
    1              0.000001 augroup END
                            
                            "
                            " on_insert_leave
                            "
    1              0.000001 function! s:on_insert_leave() abort
                              let l:session = vsnip#get_session()
                              if !empty(l:session)
                                call l:session.on_insert_leave()
                              endif
                            endfunction
                            
                            "
                            " on_text_changed
                            "
    1              0.000001 function! s:on_text_changed() abort
                              let l:session = vsnip#get_session()
                              if !empty(l:session)
                                call l:session.on_text_changed()
                              endif
                            endfunction
                            
                            "
                            " on_buf_write_post
                            "
    1              0.000001 function! s:on_buf_write_post() abort
                              call vsnip#source#refresh(resolve(fnamemodify(bufname('%'), ':p')))
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vsnip.vim
Sourced 1 time
Total time:   0.002408
 Self time:   0.000127

count  total (s)   self (s)
    1   0.002257   0.000041 let s:Session = vsnip#session#import()
    1   0.000005   0.000004 let s:Snippet = vsnip#snippet#import()
    1   0.000039   0.000005 let s:TextEdit = vital#vsnip#import('VS.LSP.TextEdit')
    1   0.000034   0.000004 let s:Position = vital#vsnip#import('VS.LSP.Position')
                            
    1              0.000001 let s:session = v:null
    1              0.000001 let s:selected_text = ''
                            
    1              0.000001 let g:vsnip#DeactivateOn = {}
    1              0.000002 let g:vsnip#DeactivateOn.OutsideOfSnippet = 1
    1              0.000001 let g:vsnip#DeactivateOn.OutsideOfCurrentTabstop = 2
                            
                            "
                            " vsnip#selected_text.
                            "
    1              0.000001 function! vsnip#selected_text(...) abort
                              if len(a:000) == 1
                                let s:selected_text = a:000[0]
                              else
                                return s:selected_text
                              endif
                            endfunction
                            
                            "
                            " vsnip#available.
                            "
    1              0.000001 function! vsnip#available(...) abort
                              let l:direction = get(a:000, 0, 1)
                              return vsnip#expandable() || vsnip#jumpable(l:direction)
                            endfunction
                            
                            "
                            " vsnip#expandable.
                            "
    1              0.000001 function! vsnip#expandable() abort
                              return !empty(vsnip#get_context())
                            endfunction
                            
                            "
                            " vsnip#jumpable.
                            "
    1              0.000001 function! vsnip#jumpable(...) abort
                              let l:direction = get(a:000, 0, 1)
                              return !empty(s:session) && s:session.jumpable(l:direction)
                            endfunction
                            
                            "
                            " vsnip#expand
                            "
    1              0.000001 function! vsnip#expand() abort
                              let l:context = vsnip#get_context()
                              if !empty(l:context)
                                call s:TextEdit.apply(bufnr('%'), [{
                                \   'range': l:context.range,
                                \   'newText': ''
                                \ }])
                                call vsnip#anonymous(join(l:context.snippet.body, "\n"), {
                                \   'position': l:context.range.start
                                \ })
                              endif
                            endfunction
                            
                            "
                            " vsnip#anonymous.
                            "
    1              0.000001 function! vsnip#anonymous(text, ...) abort
                              let l:option = get(a:000, 0, {})
                              let l:prefix = get(l:option, 'prefix', v:null)
                              let l:position = get(l:option, 'position', s:Position.cursor())
                            
                              if l:prefix isnot# v:null
                                let l:position.character -= strchars(l:prefix)
                                call s:TextEdit.apply(bufnr('%'), [{
                                \   'range': {
                                \     'start': l:position,
                                \     'end': {
                                \       'line': l:position.line,
                                \       'character': l:position.character + strchars(l:prefix),
                                \     },
                                \   },
                                \   'newText': ''
                                \ }])
                              endif
                            
                              let l:session = s:Session.new(bufnr('%'), l:position, a:text)
                            
                              call vsnip#selected_text('')
                            
                              if !empty(s:session)
                                call s:session.flush_changes() " try to sync buffer content because vsnip#expand maybe remove prefix
                              endif
                            
                              if empty(s:session)
                                let s:session = l:session
                                call s:session.expand()
                              else
                                call s:session.merge(l:session)
                              endif
                            
                              doautocmd <nomodeline> User vsnip#expand
                            
                              call s:session.refresh()
                              call s:session.jump(1)
                            endfunction
                            
                            "
                            " vsnip#get_session
                            "
    1              0.000001 function! vsnip#get_session() abort
                              return s:session
                            endfunction
                            
                            "
                            " vsnip#deactivate
                            "
    1              0.000001 function! vsnip#deactivate() abort
                              let s:session = {}
                            endfunction
                            
                            "
                            " get_context.
                            "
    1              0.000001 function! vsnip#get_context() abort
                              let l:offset = mode()[0] ==# 'i' ? 2 : 1
                              let l:before_text = getline('.')[0 : col('.') - l:offset]
                              let l:before_text_len = strchars(l:before_text)
                            
                              if l:before_text_len == 0
                                return {}
                              endif
                            
                              let l:sources = vsnip#source#find(bufnr('%'))
                            
                              " Search prefix
                              for l:source in l:sources
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix
                                    let l:prefix_len = strchars(l:prefix)
                                    if strcharpart(l:before_text, l:before_text_len - l:prefix_len, l:prefix_len) !=# l:prefix
                                      continue
                                    endif
                                    if l:prefix =~# '^\h' && l:before_text !~# '\<\V' . escape(l:prefix, '\/?') . '\m$'
                                      continue
                                    endif
                                    return s:create_context(l:snippet, l:before_text_len, l:prefix_len)
                                  endfor
                                endfor
                              endfor
                            
                              " Search prefix-alias
                              for l:source in l:sources
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix_alias
                                    let l:prefix_len = strchars(l:prefix)
                                    if strcharpart(l:before_text, l:before_text_len - l:prefix_len, l:prefix_len) !=# l:prefix
                                      continue
                                    endif
                                    if l:prefix =~# '^\h' && l:before_text !~# '\<\V' . escape(l:prefix, '\/?') . '\m$'
                                      continue
                                    endif
                                    return s:create_context(l:snippet, l:before_text_len, l:prefix_len)
                                  endfor
                                endfor
                              endfor
                            
                              return {}
                            endfunction
                            
                            "
                            " vsnip#get_complete_items
                            "
    1              0.000001 function! vsnip#get_complete_items(bufnr) abort
                              let l:uniq = {}
                              let l:candidates = []
                            
                              for l:source in vsnip#source#find(a:bufnr)
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix
                                    if has_key(l:uniq, l:prefix)
                                      continue
                                    endif
                                    let l:uniq[l:prefix] = v:true
                            
                                    let l:menu = ''
                                    let l:menu .= '[v]'
                                    let l:menu .= ' '
                                    let l:menu .= (strlen(l:snippet.description) > 0 ? l:snippet.description : l:snippet.label)
                            
                                    call add(l:candidates, {
                                    \   'word': l:prefix,
                                    \   'abbr': l:prefix,
                                    \   'kind': 'Snippet',
                                    \   'menu': l:menu,
                                    \   'dup': 1,
                                    \   'user_data': json_encode({
                                    \     'vsnip': {
                                    \       'snippet': l:snippet.body
                                    \     }
                                    \   })
                                    \ })
                                  endfor
                                endfor
                              endfor
                            
                              return l:candidates
                            endfunction
                            
                            "
                            " vsnip#decode
                            "
    1              0.000001 function! vsnip#to_string(text) abort
                              let l:text = type(a:text) == type([]) ? join(a:text, "\n") : a:text
                              return s:Snippet.new(s:Position.cursor(), l:text).text()
                            endfunction
                            
                            "
                            " vsnip#debug
                            "
    1              0.000001 function! vsnip#debug() abort
                              if !empty(s:session)
                                call s:session.snippet.debug()
                              endif
                            endfunction
                            
                            "
                            " create_context
                            "
    1              0.000001 function! s:create_context(snippet, before_text_len, prefix_len) abort
                              let l:line = line('.') - 1
                              return {
                              \   'range': {
                              \     'start': {
                              \       'line': l:line,
                              \       'character': a:before_text_len - a:prefix_len
                              \     },
                              \     'end': {
                              \       'line': l:line,
                              \       'character': a:before_text_len
                              \     }
                              \   },
                              \   'snippet': a:snippet
                              \ }
                            endfunction

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vsnip/session.vim
Sourced 1 time
Total time:   0.002210
 Self time:   0.000135

count  total (s)   self (s)
    1   0.000879   0.000043 let s:Snippet = vsnip#snippet#import()
    1   0.000961   0.000005 let s:TextEdit = vital#vsnip#import('VS.LSP.TextEdit')
    1   0.000037   0.000005 let s:Position = vital#vsnip#import('VS.LSP.Position')
    1   0.000255   0.000004 let s:Diff = vital#vsnip#import('VS.LSP.Diff')
                            
                            "
                            " import.
                            "
    1              0.000001 function! vsnip#session#import() abort
                              return s:Session
                            endfunction
                            
    1              0.000001 let s:Session = {}
                            
                            "
                            " new.
                            "
    1              0.000001 function! s:Session.new(bufnr, position, text) abort
                              return extend(deepcopy(s:Session), {
                              \   'bufnr': a:bufnr,
                              \   'buffer': getbufline(a:bufnr, '^', '$'),
                              \   'timer_id': -1,
                              \   'changedtick': getbufvar(a:bufnr, 'changedtick', 0),
                              \   'snippet': s:Snippet.new(a:position, vsnip#indent#adjust_snippet_body(getline('.'), a:text)),
                              \   'tabstop': -1,
                              \   'changenr': changenr(),
                              \   'changenrs': {},
                              \ })
                            endfunction
                            
                            "
                            " expand.
                            "
    1              0.000001 function! s:Session.expand() abort
                              " insert snippet.
                              call s:TextEdit.apply(self.bufnr, [{
                              \   'range': {
                              \     'start': self.snippet.position,
                              \     'end': self.snippet.position
                              \   },
                              \   'newText': self.snippet.text()
                              \ }])
                              call self.store(changenr())
                            endfunction
                            
                            "
                            " merge.
                            "
    1              0.000001 function! s:Session.merge(session) abort
                              call s:TextEdit.apply(self.bufnr, self.snippet.sync())
                              call self.store(self.changenr)
                            
                              call a:session.expand()
                              call self.snippet.merge(self.tabstop, a:session.snippet)
                              call self.snippet.insert(deepcopy(a:session.snippet.position), a:session.snippet.children)
                              call s:TextEdit.apply(self.bufnr, self.snippet.sync())
                              call self.store(changenr())
                            endfunction
                            
                            "
                            " jumpable.
                            "
    1              0.000001 function! s:Session.jumpable(direction) abort
                              if a:direction == 1
                                let l:jumpable = !empty(self.snippet.get_next_jump_point(self.tabstop))
                              else
                                let l:jumpable = !empty(self.snippet.get_prev_jump_point(self.tabstop))
                              endif
                              return l:jumpable
                            endfunction
                            
                            "
                            " jump.
                            "
    1              0.000001 function! s:Session.jump(direction) abort
                              call self.flush_changes()
                            
                              if a:direction == 1
                                let l:jump_point = self.snippet.get_next_jump_point(self.tabstop)
                              else
                                let l:jump_point = self.snippet.get_prev_jump_point(self.tabstop)
                              endif
                            
                              if empty(l:jump_point)
                                return
                              endif
                            
                              let self.tabstop = l:jump_point.placeholder.id
                            
                              " choice.
                              if len(l:jump_point.placeholder.choice) > 0
                                call self.choice(l:jump_point)
                            
                                " select.
                              elseif l:jump_point.range.start.character != l:jump_point.range.end.character
                                call self.select(l:jump_point)
                            
                                " move.
                              else
                                call self.move(l:jump_point)
                              endif
                            
                              doautocmd <nomodeline> User vsnip#jump
                            endfunction
                            
                            "
                            " choice.
                            "
    1              0.000001 function! s:Session.choice(jump_point) abort
                              call self.move(a:jump_point)
                            
                              let l:fn = {}
                              let l:fn.jump_point = a:jump_point
                              function! l:fn.next_tick() abort
                                if mode()[0] ==# 'i'
                                  let l:pos = s:Position.lsp_to_vim('%', self.jump_point.range.start)
                                  call complete(l:pos[1], map(copy(self.jump_point.placeholder.choice), { k, v -> {
                                  \   'word': v.escaped,
                                  \   'abbr': v.escaped,
                                  \   'menu': '[vsnip]',
                                  \   'kind': 'Choice'
                                  \ } }))
                                endif
                              endfunction
                              call timer_start(g:vsnip_choice_delay, { -> l:fn.next_tick() })
                            endfunction
                            
                            "
                            " select.
                            "
                            " @NOTE: Must work even if virtualedit=all/onmore or not.
                            "
    1              0.000001 function! s:Session.select(jump_point) abort
                              let l:start_pos = s:Position.lsp_to_vim('%', a:jump_point.range.start)
                              let l:end_pos = s:Position.lsp_to_vim('%', a:jump_point.range.end)
                            
                              let l:cmd = ''
                              let l:cmd .= "\<Cmd>set virtualedit=onemore\<CR>"
                              let l:cmd .= mode()[0] ==# 'i' ? "\<Esc>" : ''
                              let l:cmd .= printf("\<Cmd>call cursor(%s, %s)\<CR>", l:start_pos[0], l:start_pos[1])
                              let l:cmd .= 'v'
                              let l:cmd .= printf("\<Cmd>call cursor(%s, %s)\<CR>%s", l:end_pos[0], l:end_pos[1], &selection ==# 'exclusive' ? '' : 'h')
                              if get(g:, 'vsnip_test_mode', v:false)
                                let l:cmd .= "\<Esc>gv"
                              endif
                              let l:cmd .= printf("\<Cmd>set virtualedit=%s\<CR>", &virtualedit)
                              let l:cmd .= "\<C-g>"
                              call feedkeys(l:cmd, 'ni')
                            endfunction
                            
                            "
                            " move.
                            "
                            " @NOTE: Must work even if virtualedit=all/onmore or not.
                            "
    1              0.000001 function! s:Session.move(jump_point) abort
                              let l:pos = s:Position.lsp_to_vim('%', a:jump_point.range.end)
                            
                              call cursor(l:pos)
                            
                              if mode()[0] ==# 'n'
                                if l:pos[1] != getcurpos()[2]
                                  call feedkeys('a', 'ni')
                                else
                                  call feedkeys('i', 'ni')
                                endif
                              endif
                            endfunction
                            
                            "
                            " refresh
                            "
    1              0.000001 function! s:Session.refresh() abort
                              let self.buffer = getbufline(self.bufnr, '^', '$')
                              let self.changedtick = getbufvar(self.bufnr, 'changedtick', 0)
                            endfunction
                            
                            "
                            " on_insert_leave
                            "
    1              0.000001 function! s:Session.on_insert_leave() abort
                              call self.flush_changes()
                            endfunction
                            
                            "
                            " on_text_changed
                            "
    1              0.000001 function! s:Session.on_text_changed() abort
                              if self.bufnr != bufnr('%')
                                return vsnip#deactivate()
                              endif
                            
                              let l:changenr = changenr()
                            
                              " save state.
                              if self.changenr != l:changenr
                                call self.store(self.changenr)
                                if has_key(self.changenrs, l:changenr)
                                  let self.tabstop = self.changenrs[l:changenr].tabstop
                                  let self.snippet = self.changenrs[l:changenr].snippet
                                  let self.changenr = l:changenr
                                  let self.buffer = getbufline(self.bufnr, '^', '$')
                                  return
                                endif
                              endif
                            
                              if g:vsnip_sync_delay == 0
                                call self.flush_changes()
                              elseif g:vsnip_sync_delay > 0
                                call timer_stop(self.timer_id)
                                let self.timer_id = timer_start(g:vsnip_sync_delay, { -> self.flush_changes() }, { 'repeat': 1 })
                              endif
                            endfunction
                            
                            "
                            " flush_changes
                            "
    1              0.000001 function! s:Session.flush_changes() abort
                              let l:changedtick = getbufvar(self.bufnr, 'changedtick', 0)
                              if self.changedtick == l:changedtick
                                return
                              endif
                              let self.changedtick = l:changedtick
                            
                              " compute diff.
                              let l:buffer = getbufline(self.bufnr, '^', '$')
                              let l:diff = s:Diff.compute(self.buffer, l:buffer)
                              let self.buffer = l:buffer
                              if l:diff.rangeLength == 0 && l:diff.text ==# ''
                                return
                              endif
                            
                              " if follow succeeded, sync placeholders and write back to the buffer.
                              if self.snippet.follow(self.tabstop, l:diff)
                                try
                                  let l:text_edits = self.snippet.sync()
                                  if len(l:text_edits) > 0
                                    undojoin | call s:TextEdit.apply(self.bufnr, l:text_edits)
                                  endif
                                  call self.refresh()
                                catch /.*/
                                  " TODO: More strict changenrs mangement.
                                  call vsnip#deactivate()
                                endtry
                              else
                                call vsnip#deactivate()
                              endif
                            endfunction
                            
                            "
                            " save.
                            "
    1              0.000001 function! s:Session.store(changenr) abort
                              let self.changenrs[a:changenr] = {
                              \   'tabstop': self.tabstop,
                              \   'snippet': deepcopy(self.snippet)
                              \ }
                              let self.changenr = a:changenr
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vsnip/snippet.vim
Sourced 1 time
Total time:   0.000828
 Self time:   0.000231

count  total (s)   self (s)
    1              0.000002 let s:max_tabstop = 1000000
    1   0.000643   0.000046 let s:Position = vital#vsnip#import('VS.LSP.Position')
                            
                            "
                            " import.
                            "
    1              0.000001 function! vsnip#snippet#import() abort
                              return s:Snippet
                            endfunction
                            
    1              0.000001 let s:Snippet = {}
                            
                            "
                            " new.
                            "
    1              0.000001 function! s:Snippet.new(position, text) abort
                              let l:pos = s:Position.lsp_to_vim('%', a:position)
                              let l:snippet = extend(deepcopy(s:Snippet), {
                              \   'type': 'snippet',
                              \   'position': a:position,
                              \   'before_text': getline(l:pos[0])[0 : l:pos[1] - 2],
                              \   'children': vsnip#snippet#node#create_from_ast(
                              \     vsnip#snippet#parser#parse(a:text)
                              \   )
                              \ })
                              call l:snippet.init()
                              call l:snippet.sync()
                              return l:snippet
                            endfunction
                            
                            "
                            " init.
                            "
                            " NOTE: Must not use the node range in this method.
                            "
    1              0.000001 function! s:Snippet.init() abort
                              let l:fn = {}
                              let l:fn.self = self
                              let l:fn.group = {}
                              let l:fn.variable_placeholder = {}
                              let l:fn.has_final_tabstop = v:false
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  " Mark as follower placeholder.
                                  if !has_key(self.group, a:context.node.id)
                                    let self.group[a:context.node.id] = a:context.node
                                  else
                                    let a:context.node.follower = v:true
                                  endif
                            
                                  " Mark as having final tabstop
                                  if a:context.node.is_final
                                    let self.has_final_tabstop = v:true
                                  endif
                                elseif a:context.node.type ==# 'variable'
                                  " TODO refactor
                                  " variable placeholder
                                  if a:context.node.unknown
                                    let a:context.node.type = 'placeholder'
                                    let a:context.node.choice = []
                            
                                    if !has_key(self.variable_placeholder, a:context.node.name)
                                      let self.variable_placeholder[a:context.node.name] = s:max_tabstop - (len(self.variable_placeholder) + 1)
                                      let a:context.node.id = self.variable_placeholder[a:context.node.name]
                                      let a:context.node.follower = v:false
                                      let a:context.node.children = empty(a:context.node.children) ? [vsnip#snippet#node#create_text(a:context.node.name)] : a:context.node.children
                                      let self.group[a:context.node.id] =  a:context.node
                                    else
                                      let a:context.node.id = self.variable_placeholder[a:context.node.name]
                                      let a:context.node.follower = v:true
                                      let a:context.node.children = [vsnip#snippet#node#create_text(self.group[a:context.node.id].text())]
                                    endif
                                  else
                                    let l:text = a:context.node.resolve(a:context)
                                    let l:text = l:text is# v:null ? a:context.text : l:text
                                    let l:index = index(a:context.parent.children, a:context.node)
                                    call remove(a:context.parent.children, l:index)
                                    call insert(a:context.parent.children, vsnip#snippet#node#create_text(l:text), l:index)
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " Append ${MAX_TABSTOP} for the end of snippet.
                              if !l:fn.has_final_tabstop && g:vsnip_append_final_tabstop
                                let self.children += [vsnip#snippet#node#create_from_ast({
                                \   'type': 'placeholder',
                                \   'id': 0,
                                \   'choice': [],
                                \ })]
                              endif
                            endfunction
                            
                            "
                            " follow.
                            "
    1              0.000001 function! s:Snippet.follow(current_tabstop, diff) abort
                              if !self.is_followable(a:current_tabstop, a:diff)
                                return v:false
                              endif
                            
                              let a:diff.range = [
                              \   self.position_to_offset(a:diff.range.start),
                              \   self.position_to_offset(a:diff.range.end),
                              \ ]
                            
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.diff = a:diff
                              let l:fn.is_target_context_fixed = v:false
                              let l:fn.target_context = v:null
                              let l:fn.contexts = []
                              function! l:fn.traverse(context) abort
                                if self.diff.range[1] < a:context.range[0]
                                  return v:true
                                endif
                                if a:context.node.type !=# 'text'
                                  return
                                endif
                            
                                let l:included = v:false
                                let l:included = l:included || a:context.range[0] <= self.diff.range[0] && self.diff.range[0] < a:context.range[1] " right
                                let l:included = l:included || a:context.range[0] < self.diff.range[1] && self.diff.range[1] <= a:context.range[1] " left
                                let l:included = l:included || self.diff.range[0] <= a:context.range[0] && a:context.range[1] <= self.diff.range[1] " middle
                                if l:included
                                  if !self.is_target_context_fixed && (empty(self.target_context) && a:context.parent.type ==# 'placeholder' || get(a:context.parent, 'id', -1) == self.current_tabstop)
                                    let self.is_target_context_fixed = get(a:context.parent, 'id', -1) == self.current_tabstop
                                    let self.target_context = a:context
                                  endif
                                  call add(self.contexts, a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              if empty(l:fn.contexts)
                                return v:false
                              endif
                            
                              let l:fn.target_context = empty(l:fn.target_context) ? l:fn.contexts[-1] : l:fn.target_context
                            
                              let l:diff_text = a:diff.text
                              for l:context in l:fn.contexts
                                let l:diff_range = [max([a:diff.range[0], l:context.range[0]]), min([a:diff.range[1], l:context.range[1]])]
                                let l:start = l:diff_range[0] - l:context.range[0]
                                let l:end = l:diff_range[1] - l:context.range[0]
                            
                                " Create patched new text.
                                let l:new_text = strcharpart(l:context.text, 0, l:start)
                                if l:fn.target_context is# l:context
                                  let l:new_text .= l:diff_text
                                  let l:followed = v:true
                                endif
                                let l:new_text .= strcharpart(l:context.text, l:end, l:context.length - l:end)
                            
                                " Apply patched new text.
                                let l:context.node.value = l:new_text
                              endfor
                            
                              " Squash nodes when the edit was unexpected
                              let l:squashed = []
                              for l:context in l:fn.contexts
                                let l:squash_targets = l:context.parents + [l:context.node]
                                for l:i in range(len(l:squash_targets) - 1, 1, -1)
                                  let l:node = l:squash_targets[l:i]
                                  let l:parent = l:squash_targets[l:i - 1]
                            
                                  let l:should_squash = v:false
                                  let l:should_squash = l:should_squash || get(l:node, 'follower', v:false)
                                  let l:should_squash = l:should_squash || get(l:parent, 'id', v:null) is# a:current_tabstop
                                  let l:should_squash = l:should_squash || l:context isnot# l:fn.target_context && strlen(l:node.text()) == 0
                                  if l:should_squash && index(l:squashed, l:node) == -1
                                    let l:index = index(l:parent.children, l:node)
                                    call remove(l:parent.children, l:index)
                                    call insert(l:parent.children, vsnip#snippet#node#create_text(l:node.text()), l:index)
                                    call add(l:squashed, l:node)
                                  endif
                                endfor
                              endfor
                            
                              return v:true
                            endfunction
                            
                            "
                            " sync.
                            "
    1              0.000001 function! s:Snippet.sync() abort
                              let l:fn = {}
                              let l:fn.new_texts = {}
                              let l:fn.targets = []
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  if !has_key(self.new_texts, a:context.node.id)
                                    let self.new_texts[a:context.node.id] = a:context.text
                                  else
                                    if self.new_texts[a:context.node.id] !=# a:context.text
                                      call add(self.targets, {
                                      \   'range': a:context.range,
                                      \   'node': a:context.node,
                                      \   'new_text': a:context.node.transform.text(self.new_texts[a:context.node.id]),
                                      \ })
                                    endif
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " Create text_edits.
                              let l:text_edits = []
                              for l:target in l:fn.targets
                                call add(l:text_edits, {
                                \   'node': l:target.node,
                                \   'range': {
                                \     'start': self.offset_to_position(l:target.range[0]),
                                \     'end': self.offset_to_position(l:target.range[1]),
                                \   },
                                \   'newText': l:target.new_text
                                \ })
                              endfor
                            
                              " Sync placeholder text after created text_edits (the reason is to avoid using a modified range).
                              for l:text_edit in l:text_edits
                                let l:text_edit.node.children = [vsnip#snippet#node#create_text(l:text_edit.newText)]
                              endfor
                            
                              return l:text_edits
                            endfunction
                            
                            "
                            " range.
                            "
    1              0.000001 function! s:Snippet.range() abort
                              return {
                              \   'start': self.offset_to_position(0),
                              \   'end': self.offset_to_position(strchars(self.text()))
                              \ }
                            endfunction
                            
                            "
                            " text.
                            "
    1              0.000001 function! s:Snippet.text() abort
                              return join(map(copy(self.children), 'v:val.text()'), '')
                            endfunction
                            
                            "
                            " is_followable.
                            "
    1              0.000001 function! s:Snippet.is_followable(current_tabstop, diff) abort
                              if g:vsnip#DeactivateOn.OutsideOfSnippet == g:vsnip_deactivate_on
                                return vsnip#range#cover(self.range(), a:diff.range)
                              elseif g:vsnip#DeactivateOn.OutsideOfCurrentTabstop == g:vsnip_deactivate_on
                                let l:context = self.get_placeholder_context_by_tabstop(a:current_tabstop)
                                if empty(l:context)
                                  return v:false
                                endif
                                return vsnip#range#cover({
                                \   'start': self.offset_to_position(l:context.range[0]),
                                \   'end': self.offset_to_position(l:context.range[1]),
                                \ }, a:diff.range)
                              endif
                            endfunction
                            
                            "
                            " get_placeholder_nodes
                            "
    1              0.000001 function! s:Snippet.get_placeholder_nodes() abort
                              let l:fn =  {}
                              let l:fn.nodes = []
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  call add(self.nodes, a:context.node)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              return sort(l:fn.nodes, { a, b -> a.id - b.id })
                            endfunction
                            
                            "
                            " get_placeholder_context_by_tabstop
                            "
    1              0.000001 function! s:Snippet.get_placeholder_context_by_tabstop(current_tabstop) abort
                              let l:fn =  {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder' && a:context.node.id == self.current_tabstop
                                  let self.context = a:context
                                  return v:true
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                              return l:fn.context
                            endfunction
                            
                            "
                            " get_next_jump_point.
                            "
    1              0.000001 function! s:Snippet.get_next_jump_point(current_tabstop) abort
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder' && self.current_tabstop < a:context.node.id
                                  if !empty(self.context) && self.context.node.id <= a:context.node.id
                                    return v:false
                                  endif
                            
                                  let self.context = copy(a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              let l:context = l:fn.context
                              if empty(l:context)
                                return {}
                              endif
                            
                              return {
                              \   'placeholder': l:context.node,
                              \   'range': {
                              \     'start': self.offset_to_position(l:context.range[0]),
                              \     'end': self.offset_to_position(l:context.range[1])
                              \   }
                              \ }
                            endfunction
                            
                            "
                            " get_prev_jump_point.
                            "
    1              0.000001 function! s:Snippet.get_prev_jump_point(current_tabstop) abort
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder' && self.current_tabstop > a:context.node.id
                                  if !empty(self.context) && self.context.node.id >= a:context.node.id
                                    return v:false
                                  endif
                                  let self.context = copy(a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              let l:context = l:fn.context
                              if empty(l:context)
                                return {}
                              endif
                            
                              return {
                              \   'placeholder': l:context.node,
                              \   'range': {
                              \     'start': self.offset_to_position(l:context.range[0]),
                              \     'end': self.offset_to_position(l:context.range[1])
                              \   }
                              \ }
                            endfunction
                            
                            "
                            " normalize
                            "
                            " - merge adjacent text-nodes
                            "
    1              0.000001 function! s:Snippet.normalize() abort
                              let l:fn = {}
                              let l:fn.prev_context = v:null
                              function! l:fn.traverse(context) abort
                                if !empty(self.prev_context)
                                  if self.prev_context.node.type ==# 'text' && a:context.node.type ==# 'text' && self.prev_context.parent is# a:context.parent
                                    let a:context.node.value = self.prev_context.node.value . a:context.node.value
                                    call remove(self.prev_context.parent.children, index(self.prev_context.parent.children, self.prev_context.node))
                                  endif
                                endif
                                let self.prev_context = copy(a:context)
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            endfunction
                            
                            "
                            " merge
                            "
    1              0.000001 function! s:Snippet.merge(tabstop, snippet) abort
                              " increase new snippet's tabstop by current snippet's current tabstop
                              let l:offset = 1
                              let l:tabstop_map = {}
                              for l:node in a:snippet.get_placeholder_nodes()
                                if !has_key(l:tabstop_map, l:node.id)
                                  let l:tabstop_map[l:node.id] = a:tabstop + l:offset
                                endif
                                let l:node.id = l:tabstop_map[l:node.id]
                                let l:offset += 1
                              endfor
                              if empty(l:tabstop_map)
                                return
                              endif
                            
                              let l:tail = l:node
                            
                              " re-assign current snippet's tabstop by new snippet's final tabstop
                              let l:offset = 1
                              let l:tabstop_map = {}
                              for l:node in self.get_placeholder_nodes()
                                if l:node.id > a:tabstop
                                  if !has_key(l:tabstop_map, l:node.id)
                                    let l:tabstop_map[l:node.id] = l:tail.id + l:offset
                                  endif
                                  let l:node.id = l:tabstop_map[l:node.id]
                                  let l:offset += 1
                                endif
                              endfor
                            endfunction
                            
                            "
                            " insert
                            "
    1              0.000001 function! s:Snippet.insert(position, nodes_to_insert) abort
                              let l:offset = self.position_to_offset(a:position)
                            
                              " Search target node for inserting nodes.
                              let l:fn = {}
                              let l:fn.offset = l:offset
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.range[0] <= self.offset && self.offset <= a:context.range[1] && a:context.node.type ==# 'text'
                                  " prefer more deeper node.
                                  if empty(self.context) || self.context.depth <= a:context.depth
                                    let self.context = copy(a:context)
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " This condition is unexpected normally
                              let l:context = l:fn.context
                              if empty(l:context)
                                return
                              endif
                            
                              " Remove target text node
                              let l:index = index(l:context.parent.children, l:context.node)
                              call remove(l:context.parent.children, l:index)
                            
                              " Should insert into existing text node when position is middle of node
                              let l:nodes_to_insert = reverse(a:nodes_to_insert)
                              if l:context.node.value !=# ''
                                let l:off = l:offset - l:context.range[0]
                                let l:before = vsnip#snippet#node#create_text(strcharpart(l:context.node.value, 0, l:off))
                                let l:after = vsnip#snippet#node#create_text(strcharpart(l:context.node.value, l:off, strchars(l:context.node.value) - l:off))
                                let l:nodes_to_insert = [l:after] + l:nodes_to_insert + [l:before]
                              endif
                            
                              " Insert nodes.
                              for l:node in l:nodes_to_insert
                                call insert(l:context.parent.children, l:node, l:index)
                              endfor
                            
                              call self.normalize()
                            endfunction
                            
                            "
                            " offset_to_position.
                            "
                            " @param offset 0-based index for snippet text.
                            " @return position buffer position
                            "
    1              0.000001 function! s:Snippet.offset_to_position(offset) abort
                              let l:lines = split(strcharpart(self.text(), 0, a:offset), "\n", v:true)
                              return {
                              \   'line': self.position.line + len(l:lines) - 1,
                              \   'character': strchars(l:lines[-1]) + (len(l:lines) == 1 ? self.position.character : 0),
                              \ }
                            endfunction
                            
                            "
                            " position_to_offset.
                            "
                            " @param position buffer position
                            " @return 0-based index for snippet text.
                            "
    1              0.000001 function! s:Snippet.position_to_offset(position) abort
                              let l:line = a:position.line - self.position.line
                              let l:char = a:position.character - (l:line == 0 ? self.position.character : 0)
                              let l:lines = split(self.text(), "\n", v:true)[0 : l:line]
                              let l:lines[-1] = strcharpart(l:lines[-1], 0, l:char)
                              return strchars(join(l:lines, "\n"))
                            endfunction
                            
                            "
                            " traverse.
                            "
    1              0.000001 function! s:Snippet.traverse(node, callback) abort
                              let l:state = {
                              \   'offset': 0,
                              \   'before_text': self.before_text,
                              \ }
                              let l:context = {
                              \   'depth': 0,
                              \   'parent': v:null,
                              \   'parents': [],
                              \ }
                              call s:traverse(a:node, a:callback, l:state, l:context)
                            endfunction
    1              0.000001 function! s:traverse(node, callback, state, context) abort
                              let l:text = ''
                              let l:length = 0
                              if a:node.type !=# 'snippet'
                                let l:text = a:node.text()
                                let l:length = strchars(l:text)
                                if a:callback({
                                \   'node': a:node,
                                \   'text': l:text,
                                \   'length': l:length,
                                \   'parent': a:context.parent,
                                \   'parents': a:context.parents,
                                \   'depth': a:context.depth,
                                \   'offset': a:state.offset,
                                \   'before_text': a:state.before_text,
                                \   'range': [a:state.offset, a:state.offset + l:length],
                                \ })
                                  return v:true
                                endif
                              endif
                            
                              if len(a:node.children) > 0
                                let l:next_context = {
                                  \   'parent': a:node,
                                  \   'parents': a:context.parents + [a:node],
                                  \   'depth': len(a:context.parents) + 1,
                                  \ }
                                for l:child in copy(a:node.children)
                                  if s:traverse(l:child, a:callback, a:state, l:next_context)
                                    return v:true
                                  endif
                                endfor
                              else
                                let a:state.before_text .= l:text
                                let a:state.offset += l:length
                              endif
                            endfunction
                            
                            "
                            " debug
                            "
    1              0.000001 function! s:Snippet.debug() abort
                              echomsg 'snippet.text()'
                              for l:line in split(self.text(), "\n", v:true)
                                echomsg string(l:line)
                              endfor
                              echomsg '-----'
                            
                              let l:fn = {}
                              function! l:fn.traverse(context) abort
                                echomsg repeat('    ', a:context.depth - 1) . a:context.node.to_string()
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                              echomsg ' '
                            endfunction

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim
Sourced 1 time
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
    1              0.000005 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000003 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000002 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000002 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000002 let s:loaded = {}
    1              0.000001 let s:cache_sid = {}
                            
    1              0.000004 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000002 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000001 let s:Vital = {}
                            
    1              0.000002 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000001 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1              0.000004 let s:Vital.vital_files = function('s:vital_files')
                            
    1              0.000001 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1              0.000003 let s:Vital.import = function('s:import')
                            
    1              0.000001 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1              0.000002 let s:Vital.load = function('s:load')
                            
    1              0.000001 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1              0.000002 let s:Vital.unload = function('s:unload')
                            
    1              0.000001 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1              0.000002 let s:Vital.exists = function('s:exists')
                            
    1              0.000001 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return uniq(modules)
                            endfunction
    1              0.000002 let s:Vital.search = function('s:search')
                            
    1              0.000001 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1              0.000002 let s:Vital.plugin_name = function('s:plugin_name')
                            
    1              0.000001 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000001 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000001 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000001 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000001 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1              0.000003 let s:Vital._import = function('s:_import')
                            
    1              0.000003 function! s:_format_throwpoint(throwpoint) abort
                              let funcs = []
                              let stack = matchstr(a:throwpoint, '^function \zs.*, .\{-} \d\+$')
                              for line in split(stack, '\.\.')
                                let m = matchlist(line, '^\(.\+\)\%(\[\(\d\+\)\]\|, .\{-} \(\d\+\)\)$')
                                if !empty(m)
                                  let [name, lnum, lnum2] = m[1:3]
                                  if empty(lnum)
                                    let lnum = lnum2
                                  endif
                                  let info = s:_get_func_info(name)
                                  if !empty(info)
                                    let attrs = empty(info.attrs) ? '' : join([''] + info.attrs)
                                    let flnum = info.lnum == 0 ? '' : printf(' Line:%d', info.lnum + lnum)
                                    call add(funcs, printf('function %s(...)%s Line:%d (%s%s)',
                                    \        info.funcname, attrs, lnum, info.filename, flnum))
                                    continue
                                  endif
                                endif
                                " fallback when function information cannot be detected
                                call add(funcs, line)
                              endfor
                              return join(funcs, "\n")
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000001 function! s:_get_func_info(name) abort
                              let name = a:name
                              if a:name =~# '^\d\+$'  " is anonymous-function
                                let name = printf('{%s}', a:name)
                              elseif a:name =~# '^<lambda>\d\+$'  " is lambda-function
                                let name = printf("{'%s'}", a:name)
                              endif
                              if !exists('*' . name)
                                return {}
                              endif
                              let body = execute(printf('verbose function %s', name))
                              let lines = split(body, "\n")
                              let signature = matchstr(lines[0], '^\s*\zs.*')
                              let [_, file, lnum; __] = matchlist(lines[1],
                              \   '^\t\%(Last set from\|.\{-}:\)\s*\zs\(.\{-}\)\%( \S\+ \(\d\+\)\)\?$')
                              return {
                              \   'filename': substitute(file, '[/\\]\+', '/', 'g'),
                              \   'lnum': 0 + lnum,
                              \   'funcname': a:name,
                              \   'arguments': split(matchstr(signature, '(\zs.*\ze)'), '\s*,\s*'),
                              \   'attrs': filter(['dict', 'abort', 'range', 'closure'], 'signature =~# (").*" . v:val)'),
                              \ }
                            endfunction
                            " @vimlint(EVL102, 0, l:__)
                            " @vimlint(EVL102, 0, l:_)
                            
                            " s:_get_module() returns module object which has all script local functions.
    1              0.000001 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              try
                                return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000001 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = function('s:_get_builtin_module')
    1              0.000001 else
    1              0.000002   let s:Vital._get_module = function('s:_get_module')
    1              0.000001 endif
                            
    1              0.000001 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000001 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000001 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000001 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000001 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
    1              0.000001 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000001 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(execute(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000007 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
                              let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
                              function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
    1              0.000001 else
    1              0.000001   function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000000 endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000025 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000001 function! s:sid2sfuncs(sid) abort
                              let fs = split(execute(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000001 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Position.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000047

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000002 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000056   0.000018 execute join(['function! vital#_vsnip#VS#LSP#Position#import() abort', printf("return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " cursor
                            "
    1              0.000001 function! s:cursor() abort
                              return s:vim_to_lsp('%', getpos('.')[1 : 3])
                            endfunction
                            
                            "
                            " vim_to_lsp
                            "
    1              0.000001 function! s:vim_to_lsp(expr, pos) abort
                              let l:line = s:_get_buffer_line(a:expr, a:pos[0])
                              if l:line is v:null
                                return {
                                \   'line': a:pos[0] - 1,
                                \   'character': a:pos[1] - 1
                                \ }
                              endif
                            
                              return {
                              \   'line': a:pos[0] - 1,
                              \   'character': strchars(strpart(l:line, 0, a:pos[1] - 1))
                              \ }
                            endfunction
                            
                            "
                            " lsp_to_vim
                            "
    1              0.000001 function! s:lsp_to_vim(expr, position) abort
                              let l:line = s:_get_buffer_line(a:expr, a:position.line + 1)
                              if l:line is v:null
                                return [a:position.line + 1, a:position.character + 1]
                              endif
                              return [a:position.line + 1, byteidx(l:line, a:position.character) + 1]
                            endfunction
                            
                            "
                            " _get_buffer_line
                            "
    1              0.000001 function! s:_get_buffer_line(expr, lnum) abort
                              try
                                let l:expr = bufnr(a:expr)
                              catch /.*/
                                let l:expr = a:expr
                              endtry
                              if bufloaded(l:expr)
                                return get(getbufline(l:expr, a:lnum), 0, v:null)
                              elseif filereadable(a:expr)
                                return get(readfile(a:expr, '', a:lnum), 0, v:null)
                              endif
                              return v:null
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004 let s:_plugin_name = expand('<sfile>:t:r')
                            
    1              0.000002 function! vital#{s:_plugin_name}#new() abort
                              return vital#{s:_plugin_name[1:]}#new()
                            endfunction
                            
    1              0.000002 function! vital#{s:_plugin_name}#function(funcname) abort
                              silent! return function(a:funcname)
                            endfunction

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim
Sourced 1 time
Total time:   0.000098
 Self time:   0.000081

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000002 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000031   0.000013 execute join(['function! vital#_vsnip#VS#LSP#TextEdit#import() abort', printf("return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " _vital_loaded
                            "
    1              0.000001 function! s:_vital_loaded(V) abort
                              let s:Text = a:V.import('VS.LSP.Text')
                              let s:Position = a:V.import('VS.LSP.Position')
                              let s:Buffer = a:V.import('VS.Vim.Buffer')
                              let s:Option = a:V.import('VS.Vim.Option')
                            endfunction
                            
                            "
                            " _vital_depends
                            "
    1              0.000001 function! s:_vital_depends() abort
                              return ['VS.LSP.Text', 'VS.LSP.Position', 'VS.Vim.Buffer', 'VS.Vim.Option']
                            endfunction
                            
                            "
                            " apply
                            "
    1              0.000001 function! s:apply(path, text_edits) abort
                              let l:current_bufname = bufname('%')
                              let l:current_position = s:Position.cursor()
                            
                              let l:target_bufnr = s:_switch(a:path)
                              call s:_substitute(l:target_bufnr, a:text_edits, l:current_position)
                              let l:current_bufnr = s:_switch(l:current_bufname)
                            
                              if l:current_bufnr == l:target_bufnr
                                call cursor(s:Position.lsp_to_vim('%', l:current_position))
                              endif
                            endfunction
                            
                            "
                            " _substitute
                            "
    1              0.000001 function! s:_substitute(bufnr, text_edits, current_position) abort
                              try
                                " Save state.
                                let l:Restore = s:Option.define({
                                \   'foldenable': '0',
                                \ })
                                let l:view = winsaveview()
                            
                                " Apply substitute.
                                let [l:fixeol, l:text_edits] = s:_normalize(a:bufnr, a:text_edits)
                                for l:text_edit in l:text_edits
                                  let l:start = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.start)
                                  let l:end = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.end)
                                  let l:text = s:Text.normalize_eol(l:text_edit.newText)
                                  execute printf('noautocmd keeppatterns keepjumps silent %ssubstitute/\%%%sl\%%%sc\_.\{-}\%%%sl\%%%sc/\=l:text/%se',
                                  \   l:start[0],
                                  \   l:start[0],
                                  \   l:start[1],
                                  \   l:end[0],
                                  \   l:end[1],
                                  \   &gdefault ? 'g' : ''
                                  \ )
                                  call s:_fix_cursor_position(a:current_position, l:text_edit, s:Text.split_by_eol(l:text))
                                endfor
                            
                                " Remove last empty line if fixeol enabled.
                                if l:fixeol && getline('$') ==# ''
                                  noautocmd keeppatterns keepjumps silent $delete _
                                endif
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                " Restore state.
                                call l:Restore()
                                call winrestview(l:view)
                              endtry
                            endfunction
                            
                            "
                            " _fix_cursor_position
                            "
    1              0.000001 function! s:_fix_cursor_position(position, text_edit, lines) abort
                              let l:lines_len = len(a:lines)
                              let l:range_len = (a:text_edit.range.end.line - a:text_edit.range.start.line) + 1
                            
                              if a:text_edit.range.end.line < a:position.line
                                let a:position.line += l:lines_len - l:range_len
                              elseif a:text_edit.range.end.line == a:position.line && a:text_edit.range.end.character <= a:position.character
                                let a:position.line += l:lines_len - l:range_len
                                let a:position.character = strchars(a:lines[-1]) + (a:position.character - a:text_edit.range.end.character)
                                if l:lines_len == 1
                                  let a:position.character += a:text_edit.range.start.character
                                endif
                              endif
                            endfunction
                            
                            "
                            " _normalize
                            "
    1              0.000001 function! s:_normalize(bufnr, text_edits) abort
                              let l:text_edits = type(a:text_edits) == type([]) ? a:text_edits : [a:text_edits]
                              let l:text_edits = s:_range(l:text_edits)
                              let l:text_edits = sort(l:text_edits, function('s:_compare'))
                              let l:text_edits = reverse(l:text_edits)
                              return s:_fix_text_edits(a:bufnr, l:text_edits)
                            endfunction
                            
                            "
                            " _range
                            "
    1              0.000001 function! s:_range(text_edits) abort
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if type(l:text_edit) != type({})
                                  continue
                                endif
                                if l:text_edit.range.start.line > l:text_edit.range.end.line || (
                                \   l:text_edit.range.start.line == l:text_edit.range.end.line &&
                                \   l:text_edit.range.start.character > l:text_edit.range.end.character
                                \ )
                                  let l:text_edit.range = { 'start': l:text_edit.range.end, 'end': l:text_edit.range.start }
                                endif
                                let l:text_edits += [l:text_edit]
                              endfor
                              return l:text_edits
                            endfunction
                            
                            "
                            " _compare
                            "
    1              0.000001 function! s:_compare(text_edit1, text_edit2) abort
                              let l:diff = a:text_edit1.range.start.line - a:text_edit2.range.start.line
                              if l:diff == 0
                                return a:text_edit1.range.start.character - a:text_edit2.range.start.character
                              endif
                              return l:diff
                            endfunction
                            
                            "
                            " _fix_text_edits
                            "
    1              0.000001 function! s:_fix_text_edits(bufnr, text_edits) abort
                              let l:max = s:Buffer.get_line_count(a:bufnr)
                            
                              let l:fixeol = v:false
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if l:max <= l:text_edit.range.start.line
                                  let l:text_edit.range.start.line = l:max - 1
                                  let l:text_edit.range.start.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:text_edit.newText = "\n" . l:text_edit.newText
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                if l:max <= l:text_edit.range.end.line
                                  let l:text_edit.range.end.line = l:max - 1
                                  let l:text_edit.range.end.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                call add(l:text_edits, l:text_edit)
                              endfor
                            
                              return [l:fixeol, l:text_edits]
                            endfunction
                            
                            "
                            " _switch
                            "
    1              0.000001 function! s:_switch(path) abort
                              let l:curr = bufnr('%')
                              let l:next = filereadable(a:path) ? bufnr(fnameescape(a:path)) : bufnr(a:path)
                              if l:next >= 0
                                if l:curr != l:next
                                  execute printf('noautocmd keepalt keepjumps %sbuffer!', l:next)
                                endif
                              else
                                execute printf('noautocmd keepalt keepjumps edit! %s', fnameescape(a:path))
                              endif
                              return bufnr('%')
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Text.vim
Sourced 1 time
Total time:   0.000050
 Self time:   0.000027

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000002 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000035   0.000013 execute join(['function! vital#_vsnip#VS#LSP#Text#import() abort', printf("return map({'normalize_eol': '', 'split_by_eol': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000001 delfunction s:_SID
                            " ___vital___
                            "
                            " normalize_eol
                            "
    1              0.000001 function! s:normalize_eol(text) abort
                              return substitute(a:text, "\r\n\\|\r", "\n", 'g')
                            endfunction
                            
                            "
                            " split_by_eol
                            "
    1              0.000001 function! s:split_by_eol(text) abort
                              return split(a:text, "\r\n\\|\r\\|\n", v:true)
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000093
 Self time:   0.000074

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000001 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000031   0.000012 execute join(['function! vital#_vsnip#VS#Vim#Buffer#import() abort', printf("return map({'add': '', 'do': '', 'create': '', 'get_line_count': '', 'pseudo': '', 'ensure': '', 'load': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000001 delfunction s:_SID
                            " ___vital___
    1              0.000003 let s:Do = { -> {} }
                            
    1              0.000003 let g:___VS_Vim_Buffer_id = get(g:, '___VS_Vim_Buffer_id', 0)
                            
                            "
                            " get_line_count
                            "
    1              0.000003 if exists('*nvim_buf_line_count')
    1              0.000001   function! s:get_line_count(bufnr) abort
                                return nvim_buf_line_count(a:bufnr)
                              endfunction
                            elseif has('patch-8.2.0019')
                              function! s:get_line_count(bufnr) abort
                                return getbufinfo(a:bufnr)[0].linecount
                              endfunction
                            else
                              function! s:get_line_count(bufnr) abort
                                if bufnr('%') == bufnr(a:bufnr)
                                  return line('$')
                                endif
                                return len(getbufline(a:bufnr, '^', '$'))
                              endfunction
    1              0.000000 endif
                            
                            "
                            " create
                            "
    1              0.000001 function! s:create(...) abort
                              let g:___VS_Vim_Buffer_id += 1
                              let l:bufname = printf('VS.Vim.Buffer: %s: %s',
                              \   g:___VS_Vim_Buffer_id,
                              \   get(a:000, 0, 'VS.Vim.Buffer.Default')
                              \ )
                              return s:load(l:bufname)
                            endfunction
                            
                            "
                            " ensure
                            "
    1              0.000001 function! s:ensure(expr) abort
                              if !bufexists(a:expr)
                                if type(a:expr) == type(0)
                                  throw printf('VS.Vim.Buffer: `%s` is not valid expr.', a:expr)
                                endif
                                call s:add(a:expr)
                              endif
                              return bufnr(a:expr)
                            endfunction
                            
                            "
                            " add
                            "
    1              0.000001 if exists('*bufadd')
    1              0.000001   function! s:add(name) abort
                                let l:bufnr = bufadd(a:name)
                                call setbufvar(l:bufnr, '&buflisted', 1)
                              endfunction
                            else
                              function! s:add(name) abort
                                badd `=a:name`
                              endfunction
    1              0.000000 endif
                            
                            "
                            " load
                            "
    1              0.000001 if exists('*bufload')
    1              0.000001   function! s:load(expr) abort
                                let l:bufnr = s:ensure(a:expr)
                                if !bufloaded(l:bufnr)
                                  call bufload(l:bufnr)
                                endif
                                return l:bufnr
                              endfunction
                            else
                              function! s:load(expr) abort
                                let l:curr_bufnr = bufnr('%')
                                try
                                  let l:bufnr = s:ensure(a:expr)
                                  execute printf('keepalt keepjumps silent %sbuffer', l:bufnr)
                                catch /.*/
                                  echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                                finally
                                  execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                                endtry
                                return l:bufnr
                              endfunction
    1              0.000000 endif
                            
                            "
                            " do
                            "
    1              0.000001 function! s:do(bufnr, func) abort
                              let l:curr_bufnr = bufnr('%')
                              if l:curr_bufnr == a:bufnr
                                call a:func()
                                return
                              endif
                            
                              try
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', a:bufnr)
                                call a:func()
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                              endtry
                            endfunction
                            
                            "
                            " pseudo
                            "
    1              0.000001 function! s:pseudo(filepath) abort
                              if !filereadable(a:filepath)
                                throw printf('VS.Vim.Buffer: `%s` is not valid filepath.', a:filepath)
                              endif
                            
                              " create pseudo buffer
                              let l:bufname = printf('VSVimBufferPseudo://%s', a:filepath)
                              if bufexists(l:bufname)
                                return s:ensure(l:bufname)
                              endif
                            
                              let l:bufnr = s:ensure(l:bufname)
                              let l:group = printf('VS_Vim_Buffer_pseudo:%s', l:bufnr)
                              execute printf('augroup %s', l:group)
                                execute printf('autocmd BufReadCmd <buffer=%s> call setline(1, readfile(bufname("%")[20 : -1])) | try | filetype detect | catch /.*/ | endtry | augroup %s | autocmd! | augroup END', l:bufnr, l:group)
                              augroup END
                              return l:bufnr
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Option.vim
Sourced 1 time
Total time:   0.000044
 Self time:   0.000026

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000001 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000031   0.000013 execute join(['function! vital#_vsnip#VS#Vim#Option#import() abort', printf("return map({'define': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " define
                            "
    1              0.000001 function! s:define(map) abort
                              let l:old = {}
                              for [l:key, l:value] in items(a:map)
                                let l:old[l:key] = eval(printf('&%s', l:key))
                                execute printf('let &%s = "%s"', l:key, l:value)
                              endfor
                              return { -> s:define(l:old) }
                            endfunction
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim
Sourced 1 time
Total time:   0.000108
 Self time:   0.000062

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000001 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000025   0.000011 execute join(['function! vital#_vsnip#VS#LSP#Diff#import() abort', printf("return map({'try_enable_lua': '', 'compute': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000001 delfunction s:_SID
                            " ___vital___
                            "
                            " compute
                            "
    1              0.000001 function! s:compute(old, new) abort
                              let l:old = a:old
                              let l:new = a:new
                            
                              let l:old_len = len(l:old)
                              let l:new_len = len(l:new)
                              let l:min_len = min([l:old_len, l:new_len])
                            
                              " empty -> empty
                              if l:old_len == 0 && l:new_len == 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': 0,
                                \       'character': 0,
                                \     }
                                \   },
                                \   'text': '',
                                \   'rangeLength': 0
                                \ }
                              " not empty -> empty
                              elseif l:old_len != 0 && l:new_len == 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': l:old_len - 1,
                                \       'character': strchars(l:old[-1]),
                                \     }
                                \   },
                                \   'text': '',
                                \   'rangeLength': strchars(join(l:old, "\n"))
                                \ }
                              " empty -> not empty
                              elseif l:old_len == 0 && l:new_len != 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': 0,
                                \       'character': 0,
                                \     }
                                \   },
                                \   'text': join(l:new, "\n"),
                                \   'rangeLength': 0
                                \ }
                              endif
                            
                              if s:is_lua_enabled
                                let [l:first_line, l:last_line] = luaeval('vital_vs_lsp_diff_search_line_region(_A[1], _A[2])', [l:old, l:new])
                              else
                                let l:first_line = 0
                                while l:first_line < l:min_len - 1
                                  if l:old[l:first_line] !=# l:new[l:first_line]
                                    break
                                  endif
                                  let l:first_line += 1
                                endwhile
                            
                                let l:last_line = -1
                                while l:last_line > -l:min_len + l:first_line
                                  if l:old[l:last_line] !=# l:new[l:last_line]
                                    break
                                  endif
                                  let l:last_line -= 1
                                endwhile
                              endif
                            
                              let l:old_lines = l:old[l:first_line : l:last_line]
                              let l:new_lines = l:new[l:first_line : l:last_line]
                              let l:old_text = join(l:old_lines, "\n") . "\n"
                              let l:new_text = join(l:new_lines, "\n") . "\n"
                              let l:old_text_len = strchars(l:old_text)
                              let l:new_text_len = strchars(l:new_text)
                              let l:min_text_len = min([l:old_text_len, l:new_text_len])
                            
                              let l:first_char = 0
                              for l:first_char in range(0, l:min_text_len - 1)
                                if strgetchar(l:old_text, l:first_char) != strgetchar(l:new_text, l:first_char)
                                  break
                                endif
                              endfor
                            
                              let l:last_char = 0
                              for l:last_char in range(0, -l:min_text_len + l:first_char, -1)
                                if strgetchar(l:old_text, l:old_text_len + l:last_char - 1) != strgetchar(l:new_text, l:new_text_len + l:last_char - 1)
                                  break
                                endif
                              endfor
                            
                              return {
                              \   'range': {
                              \     'start': {
                              \       'line': l:first_line,
                              \       'character': l:first_char,
                              \     },
                              \     'end': {
                              \       'line': l:old_len + l:last_line,
                              \       'character': strchars(l:old_lines[-1]) + l:last_char + 1,
                              \     }
                              \   },
                              \   'text': strcharpart(l:new_text, l:first_char, l:new_text_len + l:last_char - l:first_char),
                              \   'rangeLength': l:old_text_len + l:last_char - l:first_char
                              \ }
                            endfunction
                            
    1              0.000001 function! s:try_enable_lua() abort
                            lua <<EOF
                            function vital_vs_lsp_diff_search_line_region(old, new)
                              local old_len = #old
                              local new_len = #new
                              local min_len = math.min(#old, #new)
                            
                              local first_line = 0
                              while first_line < min_len - 1 do
                                if old[first_line + 1] ~= new[first_line + 1] then
                                  break
                                end
                                first_line = first_line + 1
                              end
                            
                              local last_line = -1
                              while last_line > -min_len + first_line do
                                if old[(old_len + last_line) + 1] ~= new[(new_len + last_line) + 1] then
                                  break
                                end
                                last_line = last_line - 1
                              end
                              return { first_line, last_line }
                            end
                            EOF
                            endfunction
                            
    1              0.000002 let s:is_lua_enabled = v:false
    1              0.000002 if has('nvim')
    1              0.000001   try
    1   0.000034   0.000004     call s:try_enable_lua()
    1              0.000002     let s:is_lua_enabled = v:true
                              catch /.*/
    1              0.000001   endtry
    1              0.000000 endif
                            

SCRIPT  /home/nagashima/.local/share/nvim/plugged/nvim-treesitter/plugin/nvim-treesitter.lua
Sourced 1 time
Total time:   0.000385
 Self time:   0.000385

count  total (s)   self (s)
                            -- Last Change: 2022 Apr 16
                            
                            if vim.g.loaded_nvim_treesitter then
                              return
                            end
                            vim.g.loaded_nvim_treesitter = true
                            
                            -- setup modules
                            require("nvim-treesitter").setup()
                            
                            local api = vim.api
                            
                            -- define autocommands
                            local augroup = api.nvim_create_augroup("NvimTreesitter", {})
                            
                            api.nvim_create_autocmd("Filetype", {
                              pattern = "query",
                              group = augroup,
                              callback = function()
                                api.nvim_clear_autocmds {
                                  group = augroup,
                                  event = "BufWritePost",
                                }
                                api.nvim_create_autocmd("BufWritePost", {
                                  group = augroup,
                                  buffer = 0,
                                  callback = function(opts)
                                    require("nvim-treesitter.query").invalidate_query_file(opts.file)
                                  end,
                                  desc = "Invalidate query file",
                                })
                              end,
                              desc = "Reload query",
                            })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/neogit/plugin/neogit.lua
Sourced 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                            local api = vim.api
                            
                            api.nvim_create_user_command("Neogit", function(o)
                              local neogit = require("neogit")
                              neogit.open(require("neogit.lib.util").parse_command_args(o.fargs))
                            end, {
                              nargs = "*",
                              desc = "Open Neogit",
                              complete = function(arglead)
                                local neogit = require("neogit")
                                return neogit.complete(arglead)
                              end,
                            })
                            
                            api.nvim_create_user_command("NeogitResetState", function()
                              require("neogit.lib.state")._reset()
                            end, { nargs = "*", desc = "Reset any saved flags" })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/plenary.nvim/plugin/plenary.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            
                            " Create command for running busted
    1              0.000007 command! -nargs=1 -complete=file PlenaryBustedFile
                                  \ lua require('plenary.test_harness').test_file([[<args>]])
                            
    1              0.000004 command! -nargs=+ -complete=file PlenaryBustedDirectory
                                  \ lua require('plenary.test_harness').test_directory_command([[<args>]])
                            
    1              0.000007 nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>

SCRIPT  /home/nagashima/.local/share/nvim/plugged/diffview.nvim/plugin/diffview.lua
Sourced 1 time
Total time:   0.003076
 Self time:   0.003076

count  total (s)   self (s)
                            if vim.g.diffview_nvim_loaded or not require("diffview.bootstrap") then
                              return
                            end
                            
                            vim.g.diffview_nvim_loaded = 1
                            
                            local lazy = require("diffview.lazy")
                            
                            ---@module "diffview"
                            local arg_parser = lazy.require("diffview.arg_parser") ---@module "diffview.arg_parser"
                            local diffview = lazy.require("diffview") ---@module "diffview"
                            
                            local api = vim.api
                            local command = api.nvim_create_user_command
                            
                            -- NOTE: Need this wrapper around the completion function becuase it doesn't
                            -- exist yet.
                            local function completion(...)
                              return diffview.completion(...)
                            end
                            
                            -- Create commands
                            command("DiffviewOpen", function(ctx)
                              diffview.open(arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion })
                            
                            command("DiffviewFileHistory", function(ctx)
                              local range
                            
                              if ctx.range > 0 then
                                range = { ctx.line1, ctx.line2 }
                              end
                            
                              diffview.file_history(range, arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion, range = true })
                            
                            command("DiffviewClose", function()
                              diffview.close()
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewFocusFiles", function()
                              diffview.emit("focus_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewToggleFiles", function()
                              diffview.emit("toggle_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewRefresh", function()
                              diffview.emit("refresh_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewLog", function()
                              vim.cmd(("sp %s | norm! G"):format(
                                vim.fn.fnameescape(DiffviewGlobal.logger.outfile)
                              ))
                            end, { nargs = 0, bang = true })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/telescope.nvim/plugin/telescope.lua
Sourced 1 time
Total time:   0.000250
 Self time:   0.000250

count  total (s)   self (s)
                            if 1 ~= vim.fn.has "nvim-0.7.0" then
                              vim.api.nvim_err_writeln "Telescope.nvim requires at least nvim-0.7.0. See `:h telescope.changelog-1851`"
                              return
                            end
                            
                            if vim.g.loaded_telescope == 1 then
                              return
                            end
                            vim.g.loaded_telescope = 1
                            
                            local highlights = {
                              -- Sets the highlight for selected items within the picker.
                              TelescopeSelection = { default = true, link = "Visual" },
                              TelescopeSelectionCaret = { default = true, link = "TelescopeSelection" },
                              TelescopeMultiSelection = { default = true, link = "Type" },
                              TelescopeMultiIcon = { default = true, link = "Identifier" },
                            
                              -- "Normal" in the floating windows created by telescope.
                              TelescopeNormal = { default = true, link = "Normal" },
                              TelescopePreviewNormal = { default = true, link = "TelescopeNormal" },
                              TelescopePromptNormal = { default = true, link = "TelescopeNormal" },
                              TelescopeResultsNormal = { default = true, link = "TelescopeNormal" },
                            
                              -- Border highlight groups.
                              --   Use TelescopeBorder to override the default.
                              --   Otherwise set them specifically
                              TelescopeBorder = { default = true, link = "TelescopeNormal" },
                              TelescopePromptBorder = { default = true, link = "TelescopeBorder" },
                              TelescopeResultsBorder = { default = true, link = "TelescopeBorder" },
                              TelescopePreviewBorder = { default = true, link = "TelescopeBorder" },
                            
                              -- Title highlight groups.
                              --   Use TelescopeTitle to override the default.
                              --   Otherwise set them specifically
                              TelescopeTitle = { default = true, link = "TelescopeBorder" },
                              TelescopePromptTitle = { default = true, link = "TelescopeTitle" },
                              TelescopeResultsTitle = { default = true, link = "TelescopeTitle" },
                              TelescopePreviewTitle = { default = true, link = "TelescopeTitle" },
                            
                              TelescopePromptCounter = { default = true, link = "NonText" },
                            
                              -- Used for highlighting characters that you match.
                              TelescopeMatching = { default = true, link = "Special" },
                            
                              -- Used for the prompt prefix
                              TelescopePromptPrefix = { default = true, link = "Identifier" },
                            
                              -- Used for highlighting the matched line inside Previewer. Works only for (vim_buffer_ previewer)
                              TelescopePreviewLine = { default = true, link = "Visual" },
                              TelescopePreviewMatch = { default = true, link = "Search" },
                            
                              TelescopePreviewPipe = { default = true, link = "Constant" },
                              TelescopePreviewCharDev = { default = true, link = "Constant" },
                              TelescopePreviewDirectory = { default = true, link = "Directory" },
                              TelescopePreviewBlock = { default = true, link = "Constant" },
                              TelescopePreviewLink = { default = true, link = "Special" },
                              TelescopePreviewSocket = { default = true, link = "Statement" },
                              TelescopePreviewRead = { default = true, link = "Constant" },
                              TelescopePreviewWrite = { default = true, link = "Statement" },
                              TelescopePreviewExecute = { default = true, link = "String" },
                              TelescopePreviewHyphen = { default = true, link = "NonText" },
                              TelescopePreviewSticky = { default = true, link = "Keyword" },
                              TelescopePreviewSize = { default = true, link = "String" },
                              TelescopePreviewUser = { default = true, link = "Constant" },
                              TelescopePreviewGroup = { default = true, link = "Constant" },
                              TelescopePreviewDate = { default = true, link = "Directory" },
                              TelescopePreviewMessage = { default = true, link = "TelescopePreviewNormal" },
                              TelescopePreviewMessageFillchar = { default = true, link = "TelescopePreviewMessage" },
                            
                              -- Used for Picker specific Results highlighting
                              TelescopeResultsClass = { default = true, link = "Function" },
                              TelescopeResultsConstant = { default = true, link = "Constant" },
                              TelescopeResultsField = { default = true, link = "Function" },
                              TelescopeResultsFunction = { default = true, link = "Function" },
                              TelescopeResultsMethod = { default = true, link = "Method" },
                              TelescopeResultsOperator = { default = true, link = "Operator" },
                              TelescopeResultsStruct = { default = true, link = "Struct" },
                              TelescopeResultsVariable = { default = true, link = "SpecialChar" },
                            
                              TelescopeResultsLineNr = { default = true, link = "LineNr" },
                              TelescopeResultsIdentifier = { default = true, link = "Identifier" },
                              TelescopeResultsNumber = { default = true, link = "Number" },
                              TelescopeResultsComment = { default = true, link = "Comment" },
                              TelescopeResultsSpecialComment = { default = true, link = "SpecialComment" },
                            
                              -- Used for git status Results highlighting
                              TelescopeResultsDiffChange = { default = true, link = "DiffChange" },
                              TelescopeResultsDiffAdd = { default = true, link = "DiffAdd" },
                              TelescopeResultsDiffDelete = { default = true, link = "DiffDelete" },
                              TelescopeResultsDiffUntracked = { default = true, link = "NonText" },
                            }
                            
                            for k, v in pairs(highlights) do
                              vim.api.nvim_set_hl(0, k, v)
                            end
                            
                            -- This is like "<C-R>" in your terminal.
                            --     To use it, do `cmap <C-R> <Plug>(TelescopeFuzzyCommandSearch)
                            vim.keymap.set(
                              "c",
                              "<Plug>(TelescopeFuzzyCommandSearch)",
                              "<C-\\>e \"lua require('telescope.builtin').command_history "
                                .. '{ default_text = [=[" . escape(getcmdline(), \'"\') . "]=] }"<CR><CR>',
                              { silent = true, noremap = true }
                            )
                            
                            vim.api.nvim_create_user_command("Telescope", function(opts)
                              require("telescope.command").load_command(unpack(opts.fargs))
                            end, {
                              nargs = "*",
                              complete = function(_, line)
                                local builtin_list = vim.tbl_keys(require "telescope.builtin")
                                local extensions_list = vim.tbl_keys(require("telescope._extensions").manager)
                            
                                local l = vim.split(line, "%s+")
                                local n = #l - 2
                            
                                if n == 0 then
                                  local commands = { builtin_list, extensions_list }
                                  -- TODO(clason): remove when dropping support for Nvim 0.9
                                  if vim.fn.has "nvim-0.11" == 1 then
                                    commands = vim.iter(commands):flatten():totable()
                                  else
                                    commands = vim.tbl_flatten(commands)
                                  end
                                  table.sort(commands)
                            
                                  return vim.tbl_filter(function(val)
                                    return vim.startswith(val, l[2])
                                  end, commands)
                                end
                            
                                if n == 1 then
                                  local is_extension = vim.tbl_filter(function(val)
                                    return val == l[2]
                                  end, extensions_list)
                            
                                  if #is_extension > 0 then
                                    local extensions_subcommand_dict = require("telescope.command").get_extensions_subcommand()
                                    local commands = extensions_subcommand_dict[l[2]]
                                    table.sort(commands)
                            
                                    return vim.tbl_filter(function(val)
                                      return vim.startswith(val, l[3])
                                    end, commands)
                                  end
                                end
                            
                                local options_list = vim.tbl_keys(require("telescope.config").values)
                                table.sort(options_list)
                            
                                return vim.tbl_filter(function(val)
                                  return vim.startswith(val, l[#l])
                                end, options_list)
                              end,
                            })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/nvim-web-devicons/plugin/nvim-web-devicons.vim
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000008 if exists('g:loaded_devicons') | finish | endif
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
                            " TODO change so its easier to get
    1              0.000002 let g:nvim_web_devicons = 1
                            
    1              0.000002 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
    1              0.000002 let g:loaded_devicons = 1

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000008 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000000 endif
    1              0.000002 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000005   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000019   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000003   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000015   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000003   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000002   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000001   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000002   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000001   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000001   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000002   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000005   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000002   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000002   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000002   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000001   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000002   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000002   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000017   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000001   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000002   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000001 augroup END

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.001457
 Self time:   0.001267

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000011 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
    1   0.001436   0.001247   packadd matchit
    1              0.000002 endif

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 1 time
Total time:   0.000183
 Self time:   0.000092

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Maintainer:  Christian Brabandt
                            "  Version:     1.19
                            "  Last Change: 2023, June 28th
                            "  Repository:  https://github.com/chrisbra/matchit
                            "  Previous URL:http://www.vim.org/script.php?script_id=39
                            "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            
                            " Documentation:
                            "  The documentation is in a separate file: ../doc/matchit.txt
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " Allow user to prevent loading and prevent duplicate loading.
    1              0.000006 if exists("g:loaded_matchit") || &cp
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_matchit = 1
                            
    1              0.000002 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000002 fun MatchEnable()
                              nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
                              nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
                              xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>
                                    \:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
                              xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
                              onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
                              onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
                              " Analogues of [{ and ]} using matching patterns:
                              nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
                              nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
                              xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
                              xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
                              onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
                              onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
                              " text object:
                              xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
                            
                              if !exists("g:no_plugin_maps")
                                nmap <silent> %  <Plug>(MatchitNormalForward)
                                nmap <silent> g% <Plug>(MatchitNormalBackward)
                                xmap <silent> %  <Plug>(MatchitVisualForward)
                                xmap <silent> g% <Plug>(MatchitVisualBackward)
                                omap <silent> %  <Plug>(MatchitOperationForward)
                                omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                                " Analogues of [{ and ]} using matching patterns:
                                nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
                                nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
                                xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
                                xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
                                omap <silent> [% <Plug>(MatchitOperationMultiBackward)
                                omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                                " Text object
                                xmap a% <Plug>(MatchitVisualTextObject)
                              endif
                            endfun
                            
    1              0.000001 fun MatchDisable()
                              " remove all the setup keymappings
                              nunmap %
                              nunmap g%
                              xunmap %
                              xunmap g%
                              ounmap %
                              ounmap g%
                            
                              nunmap [%
                              nunmap ]%
                              xunmap [%
                              xunmap ]%
                              ounmap [%
                              ounmap ]%
                            
                              xunmap a%
                            endfun
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000010 if !exists(":MatchDebug")
    1              0.000006   command! -nargs=0 MatchDebug call matchit#Match_debug()
    1              0.000000 endif
    1              0.000002 if !exists(":MatchDisable")
    1              0.000001   command! -nargs=0 MatchDisable :call MatchDisable()
    1              0.000000 endif
    1              0.000001 if !exists(":MatchEnable")
    1              0.000001   command! -nargs=0 MatchEnable :call MatchEnable()
    1              0.000000 endif
                            
    1   0.000099   0.000008 call MatchEnable()
                            
    1              0.000003 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Oct 20
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
    1              0.000005 if exists("g:loaded_matchparen") || &cp
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000001   let g:matchparen_timeout = 300
    1              0.000000 endif
    1              0.000001 if !exists("g:matchparen_insert_timeout")
    1              0.000001   let g:matchparen_insert_timeout = 60
    1              0.000000 endif
                            
    1              0.000004 let s:has_matchaddpos = exists('*matchaddpos')
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000009   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000002   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
    1              0.000003   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
    1              0.000002   if exists('##TextChanged')
    1              0.000004     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000002     autocmd! TextChangedP * call s:Remove_Matches()
    1              0.000000   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000004 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000000 endif
                            
    1              0.000001 let s:cpo_save = &cpo
    1              0.000003 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000001 func s:Highlight_Matching_Pair()
                              if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
                              endif
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))'
                                    \ . '->indexof({_, id -> synIDattr(id, "name") =~? '
                                    \ . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000001 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000002 command DoMatchParen call s:DoMatchParen()
    1              0.000002 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000001 func s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000003 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Date:		Feb 09, 2021
                            " Last Change:
                            "   2024 May 08 by Vim Project: cleanup legacy Win9X checks
                            " Former Maintainer:   Charles E Campbell
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000001 endif
    1              0.000002 let g:loaded_netrwPlugin = "v173"
    1              0.000001 let s:keepcpo = &cpo
    1              0.000003 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000001 augroup FileExplorer
    1              0.000003  au!
    1              0.000004  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000002  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000002  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000003  if has("win32")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000000  endif
    1              0.000000 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000002  au!
    1              0.000003  au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
    1              0.000014  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000015  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000012  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000014  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001  try
    1              0.000012   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000001  endtry
    1              0.000000 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000007 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000006 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000004 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002 com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000006 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000003 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000002 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000002 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000003 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000002 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000002 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000002 if !exists("g:netrw_nogx")
    1              0.000017  if maparg('gx','n') == ""
                              if !hasmapto('<Plug>NetrwBrowseX')
                               nmap <unique> gx <Plug>NetrwBrowseX
                              endif
                              nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
    1              0.000000  endif
    1              0.000003  if maparg('gx','x') == ""
                              if !hasmapto('<Plug>NetrwBrowseXVis')
                               xmap <unique> gx <Plug>NetrwBrowseXVis
                              endif
                              xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000000  endif
    1              0.000000 endif
    1              0.000002 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000002 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000001 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Hchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000003 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000137
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000003 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1              0.000004 if index(v:argv, "--clean") < 0
    1   0.000092   0.000005   call s:LoadRemotePlugins()
    1              0.000001 endif

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_shada_plugin = 1
                            
    1              0.000001 augroup ShaDaCommands
    1              0.000003   autocmd!
    1              0.000008   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000005   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000005   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000004   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000004   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000004   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000001 augroup END

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000007 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000000 endif
    1              0.000002 let loaded_spellfile_plugin = 1
                            
    1              0.000004 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000000 endif
    1              0.000002 let g:loaded_tarPlugin = "v32"
    1              0.000001 let s:keepcpo          = &cpo
    1              0.000003 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001 augroup tar
    1              0.000003   au!
    1              0.000005   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000002   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000002   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000001   if has("unix")
    1              0.000003    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000002    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000002    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000002    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000000   endif
                            
    1              0.000002   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000006   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tzst			call tar#Browse(expand("<amatch>"))
    1              0.000000 augroup END
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000002 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000007 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000000 endif
    1              0.000002 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000005 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Dec 07, 2021
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Former Maintainer:	Charles E Campbell
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000000 endif
    1              0.000002 let g:loaded_zipPlugin = "v33"
    1              0.000001 let s:keepcpo          = &cpo
    1              0.000003 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000002 if !exists("g:zipPlugin_ext")
    1              0.000005  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000000 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000003  au!
    1              0.000004  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000002  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000002  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000002  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000001  if has("unix")
    1              0.000002   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000002   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000002   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000002   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000000  endif
                            
    1              0.000068  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000003 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/editorconfig.lua
Sourced 1 time
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
                            local group = vim.api.nvim_create_augroup('editorconfig', {})
                            vim.api.nvim_create_autocmd({ 'BufNewFile', 'BufRead', 'BufFilePost' }, {
                              group = group,
                              callback = function(args)
                                -- Buffer-local enable has higher priority
                                local enable = vim.F.if_nil(vim.b.editorconfig, vim.g.editorconfig, true)
                                if not enable then
                                  return
                                end
                            
                                require('editorconfig').config(args.buf)
                              end,
                            })

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/man.lua
Sourced 1 time
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                            if vim.g.loaded_man ~= nil then
                              return
                            end
                            vim.g.loaded_man = true
                            
                            vim.api.nvim_create_user_command('Man', function(params)
                              local man = require('man')
                              if params.bang then
                                man.init_pager()
                              else
                                local ok, err = pcall(man.open_page, params.count, params.smods, params.fargs)
                                if not ok then
                                  vim.notify(man.errormsg or err, vim.log.levels.ERROR)
                                end
                              end
                            end, {
                              bang = true,
                              bar = true,
                              range = true,
                              addr = 'other',
                              nargs = '*',
                              complete = function(...)
                                return require('man').man_complete(...)
                              end,
                            })
                            
                            local augroup = vim.api.nvim_create_augroup('man', {})
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = augroup,
                              pattern = 'man://*',
                              nested = true,
                              callback = function(params)
                                require('man').read_page(vim.fn.matchstr(params.match, 'man://\\zs.*'))
                              end,
                            })

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/osc52.lua
Sourced 1 time
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                            local tty = false
                            for _, ui in ipairs(vim.api.nvim_list_uis()) do
                              if ui.chan == 1 and ui.stdout_tty then
                                tty = true
                                break
                              end
                            end
                            
                            if not tty or vim.g.clipboard ~= nil or vim.o.clipboard ~= '' or not os.getenv('SSH_TTY') then
                              return
                            end
                            
                            require('vim.termcap').query('Ms', function(cap, found, seq)
                              if not found then
                                return
                              end
                            
                              assert(cap == 'Ms')
                            
                              -- Check 'clipboard' and g:clipboard again to avoid a race condition
                              if vim.o.clipboard ~= '' or vim.g.clipboard ~= nil then
                                return
                              end
                            
                              -- If the terminal reports a sequence other than OSC 52 for the Ms capability
                              -- then ignore it. We only support OSC 52 (for now)
                              if not seq or not seq:match('^\027%]52') then
                                return
                              end
                            
                              local osc52 = require('vim.ui.clipboard.osc52')
                            
                              vim.g.clipboard = {
                                name = 'OSC 52',
                                copy = {
                                  ['+'] = osc52.copy('+'),
                                  ['*'] = osc52.copy('*'),
                                },
                                paste = {
                                  ['+'] = osc52.paste('+'),
                                  ['*'] = osc52.paste('*'),
                                },
                              }
                            end)

SCRIPT  /snap/nvim/2823/usr/share/nvim/runtime/plugin/tohtml.lua
Sourced 1 time
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
                            if vim.g.loaded_2html_plugin ~= nil then
                              return
                            end
                            vim.g.loaded_2html_plugin = true
                            
                            vim.api.nvim_create_user_command('TOhtml', function(args)
                              local outfile = args.args ~= '' and args.args or vim.fn.tempname() .. '.html'
                              local html = require('tohtml').tohtml()
                              vim.fn.writefile(html, outfile)
                              vim.cmd.split(outfile)
                              vim.bo.filetype = 'html'
                            end, { bar = true, nargs = '?' })

SCRIPT  /home/nagashima/.local/share/nvim/plugged/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
Sourced 1 time
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
                            require('cmp_nvim_lsp').setup()

SCRIPT  /home/nagashima/.local/share/nvim/plugged/cmp-buffer/after/plugin/cmp_buffer.lua
Sourced 1 time
Total time:   0.000446
 Self time:   0.000446

count  total (s)   self (s)
                            require('cmp').register_source('buffer', require('cmp_buffer'))

SCRIPT  /home/nagashima/.local/share/nvim/plugged/cmp-path/after/plugin/cmp_path.lua
Sourced 1 time
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
                            require('cmp').register_source('path', require('cmp_path').new())

SCRIPT  /home/nagashima/.local/share/nvim/plugged/cmp-cmdline/after/plugin/cmp_cmdline.lua
Sourced 1 time
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
                            require('cmp').register_source('cmdline', require('cmp_cmdline').new())

SCRIPT  /home/nagashima/.local/share/nvim/plugged/cmp-vsnip/after/plugin/cmp_vsnip.lua
Sourced 1 time
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
                            require('cmp').register_source('vsnip', require('cmp_vsnip').new())

FUNCTION  vital#_vsnip#VS#Vim#Option#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Option.vim:7
Called 1 time
Total time:   0.000009
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000009   0.000007 return map({'define': ''}, "vital#_vsnip#function('<SNR>21_' . v:key)")

FUNCTION  vital#_vsnip#VS#LSP#Diff#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim:7
Called 1 time
Total time:   0.000016
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000015   0.000011 return map({'try_enable_lua': '', 'compute': ''}, "vital#_vsnip#function('<SNR>22_' . v:key)")

FUNCTION  <SNR>4_is_local_plug()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:500
Called 16 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   16              0.000036     return a:repo[0] =~ '[/$~]'

FUNCTION  vital#_vsnip#VS#Vim#Buffer#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Buffer.vim:7
Called 1 time
Total time:   0.000042
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000042   0.000029 return map({'add': '', 'do': '', 'create': '', 'get_line_count': '', 'pseudo': '', 'ensure': '', 'load': ''}, "vital#_vsnip#function('<SNR>20_' . v:key)")

FUNCTION  <SNR>4_infer_properties()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:744
Called 16 times
Total time:   0.000451
 Self time:   0.000318

count  total (s)   self (s)
   16              0.000015   let repo = a:repo
   16   0.000088   0.000049   if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(s:plug_expand(repo)) }
   16              0.000005   else
   16              0.000018     if repo =~ ':'
                                  let uri = repo
   16              0.000005     else
   16              0.000017       if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
   16              0.000005       endif
   16              0.000030       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
   16              0.000027       let uri = printf(fmt, repo)
   16              0.000005     endif
   16   0.000165   0.000071     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif

FUNCTION  <SNR>34_GetOldManifestPaths()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/plugin/rplugin.vim:28
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000005   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
    1              0.000010   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
    1              0.000002   if !has('win32')
    1              0.000001     return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]

FUNCTION  <SNR>34_LoadRemotePlugins()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/plugin/rplugin.vim:58
Called 1 time
Total time:   0.000087
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000081   0.000007   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000003   if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000000   endif

FUNCTION  MatchEnable()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim:49
Called 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000009   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
    1              0.000004   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
    1              0.000008   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
    1              0.000004   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
    1              0.000004   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
    1              0.000003   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
                              " Analogues of [{ and ]} using matching patterns:
    1              0.000003   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
    1              0.000003   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
    1              0.000003   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
    1              0.000003   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
    1              0.000003   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
    1              0.000003   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
                              " text object:
    1              0.000005   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
                            
    1              0.000002   if !exists("g:no_plugin_maps")
    1              0.000003     nmap <silent> %  <Plug>(MatchitNormalForward)
    1              0.000003     nmap <silent> g% <Plug>(MatchitNormalBackward)
    1              0.000002     xmap <silent> %  <Plug>(MatchitVisualForward)
    1              0.000002     xmap <silent> g% <Plug>(MatchitVisualBackward)
    1              0.000002     omap <silent> %  <Plug>(MatchitOperationForward)
    1              0.000002     omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                                " Analogues of [{ and ]} using matching patterns:
    1              0.000003     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
    1              0.000002     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
    1              0.000002     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
    1              0.000002     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
    1              0.000002     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
    1              0.000002     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                                " Text object
    1              0.000002     xmap a% <Plug>(MatchitVisualTextObject)
    1              0.000000   endif

FUNCTION  <SNR>4_escrtp()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:521
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005   return escape(a:path, ' ,')

FUNCTION  <SNR>15__import_func_name()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:242
Called 6 times
Total time:   0.000067
 Self time:   0.000042

count  total (s)   self (s)
    6   0.000066   0.000041   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  <SNR>4_split_rtp()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:2816
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000060   return split(&rtp, '\\\@<!,')

FUNCTION  <SNR>33_LocalBrowse()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/plugin/netrwPlugin.vim:105
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000002   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  plug#begin()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:208
Called 1 time
Total time:   0.000097
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000002   if a:0 > 0
                                let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
    1              0.000002   elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
    1              0.000002   elseif has('nvim')
    1              0.000004     let home = stdpath('data') . '/plugged'
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
    1              0.000000   endif
    1   0.000017   0.000007   if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
    1              0.000000   endif
                            
    1              0.000001   let g:plug_home = home
    1              0.000001   let g:plugs = {}
    1              0.000001   let g:plugs_order = []
    1              0.000001   let s:triggers = {}
                            
    1   0.000055   0.000004   call s:define_commands()
    1              0.000001   return 1

FUNCTION  <SNR>4_rtp()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:449
Called 16 times
Total time:   0.000183
 Self time:   0.000059

count  total (s)   self (s)
   16   0.000180   0.000056   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  vital#_vsnip#VS#LSP#Position#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Position.vim:7
Called 1 time
Total time:   0.000089
 Self time:   0.000061

count  total (s)   self (s)
    1   0.000089   0.000061 return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, "vital#_vsnip#function('<SNR>16_' . v:key)")

FUNCTION  <SNR>15__import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:143
Called 10 times
Total time:   0.002051
 Self time:   0.000301

count  total (s)   self (s)
   10              0.000015   if has_key(s:loaded, a:name)
    4              0.000008     return copy(s:loaded[a:name])
    6              0.000002   endif
    6   0.001180   0.000027   let module = self._get_module(a:name)
    6              0.000009   if has_key(module, '_vital_created')
                                call module._vital_created(module)
    6              0.000002   endif
    6              0.000052   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
    6              0.000011   let s:loaded[a:name] = export_module
    6              0.000007   if has_key(module, '_vital_loaded')
    1              0.000001     try
    1   0.000029   0.000019       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
    1              0.000001     endtry
    6              0.000002   endif
    6              0.000013   return copy(s:loaded[a:name])

FUNCTION  <SNR>4_dirpath()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:496
Called 16 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   16              0.000090     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  <SNR>34_GetManifestPath()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/plugin/rplugin.vim:7
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001   let manifest_base = ''
                            
    1              0.000003   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
    1              0.000000   endif
                            
    1              0.000004   let dest = stdpath('data')
    1              0.000002   if !empty(dest)
    1              0.000004     if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
    1              0.000000     endif
    1              0.000001     let manifest_base = dest
    1              0.000000   endif
                            
    1              0.000001   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>4_parse_options()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:706
Called 4 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
    4              0.000008   let opts = copy(s:base_spec)
    4              0.000005   let type = type(a:arg)
    4              0.000005   let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
    4              0.000004   if type == s:TYPE.string
                                if empty(a:arg)
                                  throw printf(opt_errfmt, 'tag', 'string')
                                endif
                                let opts.tag = a:arg
    4              0.000003   elseif type == s:TYPE.dict
   28              0.000020     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
   24              0.000058       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string')
   24              0.000006       endif
   28              0.000008     endfor
   12              0.000008     for opt in ['on', 'for']
    8              0.000023       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string or list')
    8              0.000002       endif
   12              0.000004     endfor
    4              0.000014     if has_key(a:arg, 'do') && type(a:arg.do) != s:TYPE.funcref && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
                                    throw printf(opt_errfmt, 'do', 'string or funcref')
    4              0.000001     endif
    4              0.000008     call extend(opts, a:arg)
    4              0.000004     if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(s:plug_expand(opts.dir))
    4              0.000001     endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
    4              0.000001   endif
    4              0.000002   return opts

FUNCTION  <SNR>4_loaded_names()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:406
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000017   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  <SNR>22_try_enable_lua()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim:129
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000001 lua <<EOF
                            function vital_vs_lsp_diff_search_line_region(old, new)
                              local old_len = #old
                              local new_len = #new
                              local min_len = math.min(#old, #new)
                            
                              local first_line = 0
                              while first_line < min_len - 1 do
                                if old[first_line + 1] ~= new[first_line + 1] then
                                  break
                                end
                                first_line = first_line + 1
                              end
                            
                              local last_line = -1
                              while last_line > -min_len + first_line do
                                if old[(old_len + last_line) + 1] ~= new[(new_len + last_line) + 1] then
                                  break
                                end
                                last_line = last_line - 1
                              end
                              return { first_line, last_line }
                            end
                            EOF

FUNCTION  <SNR>4_plug_fnamemodify()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:196
Called 17 times
Total time:   0.000131
 Self time:   0.000071

count  total (s)   self (s)
   17   0.000127   0.000067   return s:plug_call('fnamemodify', a:fname, a:mods)

FUNCTION  vital#_vsnip#VS#LSP#TextEdit#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim:7
Called 1 time
Total time:   0.000024
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000024   0.000017 return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, "vital#_vsnip#function('<SNR>18_' . v:key)")

FUNCTION  <SNR>34_GetManifest()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/plugin/rplugin.vim:44
Called 1 time
Total time:   0.000074
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000029   0.000004   let manifest = s:GetManifestPath()
    1              0.000005   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
    2   0.000029   0.000009     for old_manifest in s:GetOldManifestPaths()
    1              0.000004       if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
    1              0.000000       endif
    2              0.000001     endfor
    1              0.000000   endif
    1              0.000001   return manifest

FUNCTION  plug#()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:686
Called 16 times
Total time:   0.001362
 Self time:   0.000439

count  total (s)   self (s)
   16              0.000012   if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
   16              0.000005   endif
                            
   16              0.000006   try
   16   0.000116   0.000047     let repo = s:trim(a:repo)
   16   0.000321   0.000040     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
   16   0.000196   0.000075     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
   16   0.000540   0.000089     let spec = extend(s:infer_properties(name, repo), opts)
   16              0.000022     if !has_key(g:plugs, name)
   16              0.000023       call add(g:plugs_order, name)
   16              0.000005     endif
   16              0.000021     let g:plugs[name] = spec
   16              0.000029     let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(repo . ' ' . v:exception)
   16              0.000007   endtry

FUNCTION  <SNR>15__dot_to_sharp()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:273
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000023   return substitute(a:name, '\.', '#', 'g')

FUNCTION  <SNR>4_trim()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:423
Called 32 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   32              0.000140   return substitute(a:str, '[\/]\+$', '', '')

FUNCTION  <SNR>18__vital_loaded()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim:13
Called 1 time
Total time:   0.000674
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000201   0.000003   let s:Text = a:V.import('VS.LSP.Text')
    1   0.000028   0.000004   let s:Position = a:V.import('VS.LSP.Position')
    1   0.000271   0.000003   let s:Buffer = a:V.import('VS.Vim.Buffer')
    1   0.000174   0.000003   let s:Option = a:V.import('VS.Vim.Option')

FUNCTION  <SNR>4_plug_call()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:187
Called 17 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   17              0.000055     return call(a:fn, a:000)

FUNCTION  <SNR>15_new()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:22
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000007   let base = deepcopy(s:Vital)
    2              0.000003   let base._plugin_name = a:plugin_name
    2              0.000003   return base

FUNCTION  <SNR>7_SynSet()
    Defined: /snap/nvim/2823/usr/share/nvim/runtime/syntax/synload.vim:27
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000019   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000004   0verbose let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
    1              0.000000   endif

FUNCTION  <SNR>4_lazy()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:302
Called 32 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   32              0.000147   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

FUNCTION  <SNR>4_path()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:492
Called 16 times
Total time:   0.000124
 Self time:   0.000045

count  total (s)   self (s)
   16   0.000121   0.000041     return s:trim(a:path)

FUNCTION  vsnip#snippet#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vsnip/snippet.vim:7
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002   return s:Snippet

FUNCTION  <SNR>15_import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:38
Called 10 times
Total time:   0.002269
 Self time:   0.000196

count  total (s)   self (s)
   10              0.000011   let target = {}
   10              0.000009   let functions = []
   10              0.000010   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   10              0.000005   endfor
   10   0.001408   0.000281   let module = self._import(a:name)
   10              0.000012   if empty(functions)
   10              0.000031     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   10              0.000003   endif
   10              0.000006   return target

FUNCTION  <SNR>4_reorg_rtp()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:536
Called 1 time
Total time:   0.000420
 Self time:   0.000219

count  total (s)   self (s)
    1              0.000001   if !empty(s:first_rtp)
    1              0.000005     execute 'set rtp-='.s:first_rtp
    1              0.000004     execute 'set rtp-='.s:last_rtp
    1              0.000000   endif
                            
                              " &rtp is modified from outside
    1              0.000002   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
    1              0.000000   endif
                            
    1              0.000002   let s:middle = get(s:, 'middle', &rtp)
    1   0.000248   0.000047   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.000085   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000037   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000019   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000001   let s:prtp   = &rtp
                            
    1              0.000001   if !empty(s:first_rtp)
    1              0.000006     execute 'set rtp^='.s:first_rtp
    1              0.000005     execute 'set rtp+='.s:last_rtp
    1              0.000000   endif

FUNCTION  <SNR>15_plugin_name()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:112
Called 6 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    6              0.000007   return self._plugin_name

FUNCTION  <SNR>4_define_commands()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:233
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000004   command! -nargs=+ -bar Plug call plug#(<args>)
    1              0.000017   if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
    1              0.000000   endif
    1              0.000004   if has('win32') && &shellslash && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
                                return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
    1              0.000000   endif
    1              0.000003   if !has('nvim') && (has('win32') || has('win32unix')) && !has('multi_byte')
                                return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
    1              0.000000   endif
    1              0.000005   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
    1              0.000003   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
    1              0.000002   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
    1              0.000003   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
    1              0.000001   command! -nargs=0 -bar PlugStatus  call s:status()
    1              0.000001   command! -nargs=0 -bar PlugDiff    call s:diff()
    1              0.000003   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

FUNCTION  vital#_vsnip#VS#LSP#Text#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Text.vim:7
Called 1 time
Total time:   0.000017
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000017   0.000012 return map({'normalize_eol': '', 'split_by_eol': ''}, "vital#_vsnip#function('<SNR>19_' . v:key)")

FUNCTION  vsnip#session#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vsnip/session.vim:9
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return s:Session

FUNCTION  <SNR>15__get_module()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:222
Called 6 times
Total time:   0.001153
 Self time:   0.000363

count  total (s)   self (s)
    6   0.000123   0.000047   let funcname = s:_import_func_name(self.plugin_name(), a:name)
    6              0.000004   try
    6   0.001003   0.000290     return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
    6              0.000004   endtry

FUNCTION  vital#vsnip#new()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:9
Called 1 time
Total time:   0.000009
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000009   0.000003   return s:new(s:plugin_name)

FUNCTION  vital#vsnip#import()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/vsnip.vim:13
Called 6 times
Total time:   0.001677
 Self time:   0.000059

count  total (s)   self (s)
    6              0.000009   if !exists('s:V')
    1   0.000015   0.000006     let s:V = s:new(s:plugin_name)
    6              0.000002   endif
    6   0.001642   0.000032   return call(s:V.import, a:000, s:V)

FUNCTION  vital#_vsnip#function()
    Defined: ~/.local/share/nvim/plugged/vim-vsnip/autoload/vital/_vsnip.vim:7
Called 18 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   18              0.000035   silent! return function(a:funcname)

FUNCTION  plug#end()
    Defined: ~/.local/share/nvim/site/autoload/plug.vim:310
Called 1 time
Total time:   0.003319
 Self time:   0.002078

count  total (s)   self (s)
    1              0.000001   if !exists('g:plugs')
                                return s:err('plug#end() called without calling plug#begin() first')
    1              0.000000   endif
                            
    1              0.000002   if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
    1              0.000000   endif
    1              0.000002   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
    1              0.000001   if get(g:, 'did_load_filetypes', 0)
                                filetype off
    1              0.000000   endif
   17              0.000009   for name in g:plugs_order
   16              0.000018     if !has_key(g:plugs, name)
                                  continue
   16              0.000004     endif
   16              0.000016     let plug = g:plugs[name]
   16   0.000243   0.000088     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
   16              0.000017       let s:loaded[name] = 1
   16              0.000006       continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    if has('nvim-0.5.0')
                                      call s:source(s:rtp(plug), 'ftdetect/**/*.lua', 'after/ftdetect/**/*.lua')
                                    endif
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
    1              0.000001   endfor
                            
    1              0.000002   for [cmd, names] in items(lod.cmd)
                                execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
    1              0.000000   endfor
                            
    1              0.000001   for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
    1              0.000000   endfor
                            
    1              0.000001   for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
                                augroup END
    1              0.000000   endfor
                            
    1   0.000425   0.000005   call s:reorg_rtp()
    1   0.002049   0.001736   filetype plugin indent on
    1              0.000005   if has('vim_starting')
    1              0.000003     if has('syntax') && !exists('g:syntax_on')
    1   0.000448   0.000093       syntax enable
    1              0.000002     end
                              else
                                call s:reload_plugins()
    1              0.000000   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.003319   0.002078  plug#end()
   10   0.002269   0.000196  <SNR>15_import()
   10   0.002051   0.000301  <SNR>15__import()
    6   0.001677   0.000059  vital#vsnip#import()
   16   0.001362   0.000439  plug#()
    6   0.001153   0.000363  <SNR>15__get_module()
    1   0.000674   0.000015  <SNR>18__vital_loaded()
   16   0.000451   0.000318  <SNR>4_infer_properties()
    1   0.000420   0.000219  <SNR>4_reorg_rtp()
    4   0.000281             <SNR>4_parse_options()
   16   0.000183   0.000059  <SNR>4_rtp()
   32   0.000155             <SNR>4_lazy()
   32   0.000148             <SNR>4_trim()
   17   0.000131   0.000071  <SNR>4_plug_fnamemodify()
   16   0.000124   0.000045  <SNR>4_path()
    1   0.000097   0.000037  plug#begin()
   16   0.000094             <SNR>4_dirpath()
    1   0.000090             MatchEnable()
    1   0.000089   0.000061  vital#_vsnip#VS#LSP#Position#import()
    1   0.000087   0.000013  <SNR>34_LoadRemotePlugins()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   0.003319   0.002078  plug#end()
   16   0.001362   0.000439  plug#()
    6   0.001153   0.000363  <SNR>15__get_module()
   16   0.000451   0.000318  <SNR>4_infer_properties()
   10   0.002051   0.000301  <SNR>15__import()
    4              0.000281  <SNR>4_parse_options()
    1   0.000420   0.000219  <SNR>4_reorg_rtp()
   10   0.002269   0.000196  <SNR>15_import()
   32              0.000155  <SNR>4_lazy()
   32              0.000148  <SNR>4_trim()
   16              0.000094  <SNR>4_dirpath()
    1              0.000090  MatchEnable()
   17   0.000131   0.000071  <SNR>4_plug_fnamemodify()
    1   0.000089   0.000061  vital#_vsnip#VS#LSP#Position#import()
    2              0.000061  <SNR>4_split_rtp()
   17              0.000060  <SNR>4_plug_call()
   16   0.000183   0.000059  <SNR>4_rtp()
    6   0.001677   0.000059  vital#vsnip#import()
    1              0.000051  <SNR>4_define_commands()
    1              0.000045  <SNR>7_SynSet()

